---
phase: 07-ssh-key-selection
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - internal/sshkey/types.go
  - internal/sshkey/discovery.go
  - internal/sshkey/discovery_test.go
  - internal/sshkey/agent.go
  - internal/sshkey/agent_test.go
  - internal/sshkey/parser.go
  - internal/sshkey/parser_test.go
autonomous: true
must_haves:
  truths:
    - "SSH keys from ~/.ssh/ directory are discovered via file header sniffing (not naming conventions)"
    - "SSH keys loaded in the SSH agent are discovered via SSH_AUTH_SOCK"
    - "SSH keys from 1Password backend are included in discovery results"
    - "All discovered keys have type, fingerprint, comment, and source fields populated"
    - "Duplicate keys across sources are deduplicated by SHA256 fingerprint (agent source wins)"
    - "Missing key files referenced in config produce a warning-flagged entry"
    - "Discovery does not block on unavailable sources (agent down returns empty, unreadable files skipped)"
  artifacts:
    - path: "internal/sshkey/types.go"
      provides: "SSHKey domain model with Source enum, KeyType, fingerprint, comment"
      exports: ["SSHKey", "KeySource", "SourceFile", "SourceAgent", "Source1Password"]
    - path: "internal/sshkey/discovery.go"
      provides: "Multi-source discovery with file scanning, deduplication, and unified flat list"
      exports: ["DiscoverKeys", "DiscoverFileKeys"]
    - path: "internal/sshkey/agent.go"
      provides: "SSH agent key listing via SSH_AUTH_SOCK"
      exports: ["DiscoverAgentKeys"]
    - path: "internal/sshkey/parser.go"
      provides: "Private key header sniffing, type extraction, fingerprint computation"
      exports: ["ParseKeyFile", "FingerprintSHA256"]
  key_links:
    - from: "internal/sshkey/discovery.go"
      to: "internal/sshkey/parser.go"
      via: "ParseKeyFile called for each file in ~/.ssh/"
      pattern: "ParseKeyFile\\("
    - from: "internal/sshkey/discovery.go"
      to: "internal/sshkey/agent.go"
      via: "DiscoverAgentKeys called during unified discovery"
      pattern: "DiscoverAgentKeys\\("
    - from: "internal/sshkey/parser.go"
      to: "golang.org/x/crypto/ssh"
      via: "ssh.ParseRawPrivateKey and ssh.FingerprintSHA256"
      pattern: "ssh\\.(ParseRawPrivateKey|FingerprintSHA256)"
---

<objective>
Create the `internal/sshkey` package that discovers SSH keys from three sources (filesystem ~/.ssh/, SSH agent, 1Password) and returns a unified, deduplicated list with metadata (type, fingerprint, comment, source).

Purpose: This is the data layer that powers the key picker UI. It must work correctly, handle edge cases (encrypted keys, missing .pub files, agent down), and be thoroughly tested.
Output: Fully tested `sshkey` package with types, discovery, parsing, and agent integration.
</objective>

<execution_context>
@/Users/florianriquelme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/florianriquelme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/domain/server.go
@internal/backend/onepassword/client.go
@internal/backend/onepassword/mapping.go
@internal/backend/backend.go
</context>

<feature>
  <name>SSH Key Discovery Package</name>
  <files>
    internal/sshkey/types.go
    internal/sshkey/parser.go
    internal/sshkey/parser_test.go
    internal/sshkey/agent.go
    internal/sshkey/agent_test.go
    internal/sshkey/discovery.go
    internal/sshkey/discovery_test.go
  </files>
  <behavior>
    The sshkey package provides multi-source SSH key discovery:

    1. **types.go** - Domain model:
       - `KeySource` type with constants: `SourceFile`, `SourceAgent`, `Source1Password`
       - `SSHKey` struct:
         - `Path string` — filesystem path (empty for agent-only or 1P keys)
         - `Filename string` — just the filename (e.g. "id_ed25519")
         - `Type string` — key algorithm: "ed25519", "rsa", "ecdsa", "dsa" (lowercase, no "ssh-" prefix)
         - `Fingerprint string` — SHA256 fingerprint (e.g. "SHA256:abc123...")
         - `Comment string` — from .pub file or agent (empty if unavailable)
         - `Source KeySource` — where the key was found
         - `Bits int` — key size in bits (0 if unknown, relevant for RSA)
         - `Encrypted bool` — true if private key is passphrase-protected
         - `Missing bool` — true if referenced in config but file not on disk
         - `MissingPath string` — the path that was referenced but not found (only set when Missing=true)
       - `DisplayName() string` method — returns filename or "agent:<comment>" or "1p:<title>"
       - `SourceBadge() string` method — returns "[file]", "[agent]", or "[1password]"

    2. **parser.go** - Key file parsing:
       - `ParseKeyFile(path string) (*SSHKey, error)`:
         - Read first 100 bytes of file
         - Detect PEM header ("-----BEGIN") or OpenSSH format ("openssh-key-v1")
         - If detected as key: parse with ssh.ParseRawPrivateKey()
         - If passphrase-protected: catch PassphraseMissingError, set Encrypted=true, try reading .pub file for type/fingerprint instead
         - Extract type from pubkey.Type() (strip "ssh-" prefix)
         - Extract fingerprint via ssh.FingerprintSHA256(pubkey)
         - Try reading companion .pub file for comment (last field in authorized_key format)
         - Extract bits from key-specific type assertions (rsa.PublicKey → N.BitLen())
         - Return SSHKey with Source=SourceFile
       - `ReadPubKeyComment(pubPath string) string`:
         - Read .pub file, parse with ssh.ParseAuthorizedKey
         - Return comment field (empty string if .pub missing or parse fails)
       - Skip unreadable files silently (return nil, error — caller handles)

    3. **agent.go** - SSH agent discovery:
       - `DiscoverAgentKeys() ([]SSHKey, error)`:
         - Read SSH_AUTH_SOCK env var; if empty, return empty slice (not error)
         - Connect via net.Dial("unix", socketPath)
         - Create agent.NewClient(conn)
         - Call agent.List() to get []*agent.Key
         - For each agent key:
           - Parse type from key.Type() (strip "ssh-" prefix)
           - Fingerprint from ssh.FingerprintSHA256(pubkey) — parse pubkey from key.Marshal()
           - Comment from key.Comment
           - Set Source=SourceAgent
         - Return slice of SSHKey
         - On any connection error, return empty slice (not error — agent unavailable is normal)

    4. **discovery.go** - Unified multi-source discovery:
       - `DiscoverFileKeys(sshDir string) ([]SSHKey, error)`:
         - filepath.WalkDir on sshDir (default ~/.ssh/)
         - Skip directories, skip .pub files, skip known_hosts, skip config files, skip authorized_keys
         - For each remaining file: read first 100 bytes, check for PEM/OpenSSH header
         - If header matches: call ParseKeyFile()
         - Skip files that fail to parse (log nothing, just skip)
         - Return all successfully parsed keys
       - `Discover1PasswordKeys(servers []*domain.Server) []SSHKey`:
         - For each server that has an IdentityFile set:
           - Create SSHKey with Source=Source1Password
           - Try to resolve the path on disk to get type/fingerprint
           - If file doesn't exist, mark as informational (not Missing — it's a 1P reference)
         - Deduplicate by path (same IdentityFile referenced by multiple servers)
         - Return unique keys
       - `DiscoverKeys(sshDir string, servers []*domain.Server) ([]SSHKey, error)`:
         - Call DiscoverFileKeys(sshDir)
         - Call DiscoverAgentKeys()
         - Call Discover1PasswordKeys(servers)
         - Deduplicate by SHA256 fingerprint:
           - If same fingerprint found in agent and file: keep agent version (richer metadata from comment)
           - If same fingerprint found in 1P and file: keep file version (local is authoritative)
         - Sort result: file keys first (alphabetical by filename), then agent keys, then 1P keys
         - Return flat list
       - `CreateMissingKeyEntry(path string) SSHKey`:
         - Creates an SSHKey with Missing=true, MissingPath=path
         - Used when an IdentityFile is referenced in SSH config but doesn't exist on disk

    Test cases:
    - ParseKeyFile with ed25519 key -> type="ed25519", fingerprint set, Encrypted=false
    - ParseKeyFile with RSA key -> type="rsa", bits > 0
    - ParseKeyFile with encrypted key -> Encrypted=true, type still detected from .pub
    - ParseKeyFile with non-key file -> returns error
    - ParseKeyFile with missing .pub -> comment is empty string
    - DiscoverAgentKeys with no SSH_AUTH_SOCK -> returns empty slice, no error
    - DiscoverFileKeys skips .pub, known_hosts, config, authorized_keys
    - DiscoverFileKeys finds keys by header sniffing (not filename)
    - Deduplication: same key in file + agent -> agent version kept
    - Deduplication: same key in file + 1P -> file version kept
    - CreateMissingKeyEntry -> Missing=true, MissingPath set, Source=SourceFile
    - DisplayName returns filename for file keys, "agent:<comment>" for agent keys
    - SourceBadge returns correct badge string for each source
  </behavior>
  <implementation>
    Add `golang.org/x/crypto` dependency: `go get golang.org/x/crypto/ssh golang.org/x/crypto/ssh/agent`

    Use TDD RED-GREEN-REFACTOR cycle:
    - RED: Write tests for types (DisplayName, SourceBadge), parser (ParseKeyFile with test fixtures), agent (mock via interface), discovery (file walking with temp dirs)
    - GREEN: Implement each function to pass tests
    - REFACTOR: Clean up, ensure consistent error handling

    Test fixtures strategy: Create temporary directories with real key files generated via `ssh-keygen -t ed25519 -f /tmp/test_key -N ""` in test setup. For encrypted keys, use a known passphrase. For agent tests, mock the agent.ExtendedAgent interface or test against real socket in integration tests (skip if unavailable).

    Important implementation details per user decisions:
    - Scan ~/.ssh/ ONLY (no custom paths)
    - Header sniffing, NOT filename conventions (a file named "mykey" with PEM header is a valid key)
    - Include a "None (SSH default)" concept — this is handled in the picker, not in discovery
    - Do NOT set IdentitiesOnly per user decision — let SSH try other keys from agent too
    - Fingerprint format: SHA256 (e.g. "SHA256:jMx...")
    - For encrypted keys: detect via ssh.PassphraseMissingError, try .pub file for metadata
    - Handle missing .pub gracefully (empty comment, still return the key)
  </implementation>
</feature>

<verification>
1. `cd /Users/florianriquelme/Repos/mine/ssherpa && go test ./internal/sshkey/... -v` — all tests pass
2. `go vet ./internal/sshkey/...` — no issues
3. `go build ./...` — project compiles cleanly
4. Test coverage: `go test ./internal/sshkey/... -cover` shows >= 80% coverage
</verification>

<success_criteria>
- SSHKey type with all required fields and methods exists
- ParseKeyFile correctly identifies ed25519, RSA, ECDSA keys by header sniffing
- ParseKeyFile handles encrypted keys (detects passphrase, reads .pub for metadata)
- DiscoverAgentKeys returns empty slice gracefully when agent unavailable
- DiscoverFileKeys walks ~/.ssh/ and finds keys by content, not naming
- DiscoverKeys merges all sources with correct deduplication (agent wins over file for same fingerprint)
- CreateMissingKeyEntry creates proper warning entries
- All tests pass with >= 80% coverage
</success_criteria>

<output>
After completion, create `.planning/phases/07-ssh-key-selection/07-01-SUMMARY.md`
</output>
