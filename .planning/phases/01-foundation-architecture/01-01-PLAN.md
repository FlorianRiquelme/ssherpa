---
phase: 01-foundation-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - cmd/sshjesus/main.go
  - internal/domain/server.go
  - internal/domain/project.go
  - internal/domain/credential.go
  - internal/domain/validation.go
  - internal/errors/errors.go
  - internal/backend/backend.go
autonomous: true

must_haves:
  truths:
    - "Domain types Server, Project, and Credential exist with all user-specified fields"
    - "Backend interface defines read-only contract that all backends must implement"
    - "Optional Writer and Filterer interfaces exist for backends with extended capabilities"
    - "Custom error types support error chains via Unwrap() and work with errors.Is()/errors.As()"
    - "Domain models have zero external dependencies (no database tags, no storage imports)"
  artifacts:
    - path: "internal/domain/server.go"
      provides: "Server type with SSH config fields + metadata"
      contains: "type Server struct"
    - path: "internal/domain/project.go"
      provides: "Project type with server-to-project many-to-many relationship"
      contains: "type Project struct"
    - path: "internal/domain/credential.go"
      provides: "Credential type as auth reference (key file, agent, password)"
      contains: "type Credential struct"
    - path: "internal/domain/validation.go"
      provides: "Validation methods on domain types"
      contains: "func (s *Server) Validate"
    - path: "internal/errors/errors.go"
      provides: "Sentinel errors and BackendError type with Unwrap()"
      exports: ["ErrBackendUnavailable", "ErrConfigNotFound", "ErrServerNotFound", "ErrReadOnlyBackend", "BackendError"]
    - path: "internal/backend/backend.go"
      provides: "Backend, Writer, Filterer interfaces"
      contains: "type Backend interface"
    - path: "go.mod"
      provides: "Go module definition"
      contains: "module github.com/florianriquelme/sshjesus"
  key_links:
    - from: "internal/backend/backend.go"
      to: "internal/domain/server.go"
      via: "import for return types"
      pattern: "domain\\.Server"
    - from: "internal/backend/backend.go"
      to: "internal/domain/project.go"
      via: "import for return types"
      pattern: "domain\\.Project"
    - from: "internal/backend/backend.go"
      to: "internal/domain/credential.go"
      via: "import for return types"
      pattern: "domain\\.Credential"
---

<objective>
Establish the Go module, domain models, error types, and backend interface contracts for sshjesus.

Purpose: This plan creates every type and interface that Phase 1 (and all future phases) build on. Domain models encode the user's exact specifications for Server, Project, and Credential. The backend interface follows Go's database/sql pattern with optional capabilities via type assertions. Error types provide developer-friendly error chains.

Output: Compilable Go module with domain types, error types, and backend interface. No implementations yet — just contracts.
</objective>

<execution_context>
@/Users/florianriquelme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/florianriquelme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-architecture/01-CONTEXT.md
@.planning/phases/01-foundation-architecture/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Go module and create domain models</name>
  <files>
    go.mod
    cmd/sshjesus/main.go
    internal/domain/server.go
    internal/domain/project.go
    internal/domain/credential.go
    internal/domain/validation.go
  </files>
  <action>
    1. Initialize Go module: `go mod init github.com/florianriquelme/sshjesus` (use Go 1.24+).

    2. Create minimal `cmd/sshjesus/main.go` with `package main` and a placeholder `main()` that prints a version string. This is the entry point scaffold — future phases will wire it up.

    3. Create `internal/domain/server.go` with `package domain` containing:
       - `type Server struct` with ALL these fields per user decision:
         - ID string
         - Host string (hostname or IP)
         - User string (SSH username)
         - Port int (default 22)
         - IdentityFile string (path to key file)
         - Proxy string (ProxyJump / bastion host)
         - Tags []string
         - Notes string
         - LastConnected *time.Time (pointer — nil means never connected)
         - Favorite bool
         - DisplayName string (human-friendly name)
         - VPNRequired bool (flag for TUI to warn before connecting)
         - CredentialID string (references a Credential by ID)
         - ProjectIDs []string (server belongs to MULTIPLE projects per user decision)
       - Do NOT add json/toml/db struct tags — domain models are storage-agnostic per research guidance.

    4. Create `internal/domain/project.go` with:
       - `type Project struct` with:
         - ID string
         - Name string (e.g., "payments-api")
         - Description string
         - GitRemoteURLs []string (one detection method for project matching)
         - CreatedAt time.Time
         - UpdatedAt time.Time
       - Note: server-to-project relationship is tracked on the Server side (ProjectIDs), not duplicated here.

    5. Create `internal/domain/credential.go` with:
       - `type CredentialType int` enum with constants: CredentialKeyFile, CredentialSSHAgent, CredentialPassword
       - Add `String()` method on CredentialType for display
       - `type Credential struct` with:
         - ID string
         - Name string (human label, e.g., "Work SSH Key")
         - Type CredentialType
         - KeyFilePath string (populated when Type == CredentialKeyFile)
         - Notes string
       - Per user decision: Credential is an auth REFERENCE, not a secret store. Actual secrets live in filesystem, 1Password, or agent.

    6. Create `internal/domain/validation.go` with:
       - `func (s *Server) Validate() error` — validates Host is non-empty, Port is 1-65535 (default 22 if zero), DisplayName is non-empty
       - `func (p *Project) Validate() error` — validates Name is non-empty
       - `func (c *Credential) Validate() error` — validates Name is non-empty, KeyFilePath is non-empty when Type == CredentialKeyFile
       - Return plain `errors.New()` or `fmt.Errorf()` — no custom error types needed for validation (keep it simple)
       - Domain validation per research recommendation: "validation lives in domain package as methods, application layer calls before backend write operations"
  </action>
  <verify>
    Run `go build ./...` from project root — must compile with zero errors.
    Run `go vet ./...` — must pass with no warnings.
  </verify>
  <done>
    Go module initialized. Server has all 14 user-specified fields including VPNRequired, Tags, Favorite, and ProjectIDs (many-to-many). Project has GitRemoteURLs for detection. Credential is an auth reference with CredentialType enum. All three domain types have Validate() methods. No struct tags on domain types. Code compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create error types and backend interface</name>
  <files>
    internal/errors/errors.go
    internal/backend/backend.go
  </files>
  <action>
    1. Create `internal/errors/errors.go` with `package errors` (shadow stdlib errors intentionally — re-export what's needed):
       - Import standard `errors` and `fmt`
       - Sentinel errors (package-level vars):
         - `ErrBackendUnavailable = errors.New("backend unavailable")` — backend can't be reached at startup or mid-use
         - `ErrConfigNotFound = errors.New("config file not found")` — no config file exists (trigger setup wizard in future)
         - `ErrServerNotFound = errors.New("server not found")` — lookup by ID failed
         - `ErrProjectNotFound = errors.New("project not found")`
         - `ErrCredentialNotFound = errors.New("credential not found")`
         - `ErrReadOnlyBackend = errors.New("backend does not support write operations")` — write attempted on read-only backend
         - `ErrDuplicateID = errors.New("duplicate ID")` — create with existing ID
         - `ErrValidation = errors.New("validation error")` — domain validation failed
       - `type BackendError struct` with fields:
         - Op string (operation that failed: "GetServer", "CreateServer", etc.)
         - Backend string (backend name: "mock", "sshconfig", "onepassword")
         - Err error (underlying cause)
       - Implement `Error() string` returning `"{Op}: {Backend} backend: {Err}"`
       - Implement `Unwrap() error` returning Err — critical for errors.Is()/errors.As() chains
       - Re-export `errors.Is`, `errors.As`, `errors.New`, `errors.Unwrap` from stdlib so callers can import just `sshjesus/internal/errors` instead of both packages
       - Per user decision: errors are technical, surface actual messages directly, no consumer-friendly abstraction

    2. Create `internal/backend/backend.go` with `package backend`:
       - Import context and domain packages
       - `type Backend interface` (minimal — all backends MUST implement):
         - `GetServer(ctx context.Context, id string) (*domain.Server, error)`
         - `ListServers(ctx context.Context) ([]*domain.Server, error)`
         - `GetProject(ctx context.Context, id string) (*domain.Project, error)`
         - `ListProjects(ctx context.Context) ([]*domain.Project, error)`
         - `GetCredential(ctx context.Context, id string) (*domain.Credential, error)`
         - `ListCredentials(ctx context.Context) ([]*domain.Credential, error)`
         - `Close() error` (per research: keep error return for io.Closer compatibility and future 1Password cleanup)
       - `type Writer interface` (optional — backends that support write ops):
         - `CreateServer(ctx context.Context, server *domain.Server) error`
         - `UpdateServer(ctx context.Context, server *domain.Server) error`
         - `DeleteServer(ctx context.Context, id string) error`
         - `CreateProject(ctx context.Context, project *domain.Project) error`
         - `UpdateProject(ctx context.Context, project *domain.Project) error`
         - `DeleteProject(ctx context.Context, id string) error`
         - `CreateCredential(ctx context.Context, cred *domain.Credential) error`
         - `UpdateCredential(ctx context.Context, cred *domain.Credential) error`
         - `DeleteCredential(ctx context.Context, id string) error`
       - `type Filterer interface` (optional — backends with server-side query):
         - `FilterServers(ctx context.Context, filters ServerFilter) ([]*domain.Server, error)`
       - `type ServerFilter struct` with optional filter fields:
         - ProjectID string
         - Tags []string
         - Favorite *bool (pointer for tri-state: nil=any, true=favorites, false=non-favorites)
         - Query string (free text search)
       - Per user decisions: backends are storage only (CRUD), querying/filtering is optional, request/response only (no watchers/notifications)
       - All methods take context.Context per research recommendation for future-proofing
       - Include doc comments on each interface explaining the database/sql-inspired pattern and type-assertion usage

    3. Run `go mod tidy` to clean up go.mod.
  </action>
  <verify>
    Run `go build ./...` — must compile cleanly.
    Run `go vet ./...` — must pass.
    Verify that `internal/domain/` has zero imports from `internal/backend/` or `internal/errors/` (domain has no external deps within the project).
  </verify>
  <done>
    Error types with sentinel errors and BackendError (with Unwrap()) exist. Backend interface defines read-only contract. Writer interface defines optional write ops for all three domain types. Filterer interface defines optional server-side filtering. ServerFilter struct captures filter criteria. Domain package remains dependency-free. All code compiles and passes vet.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles entire module without errors
2. `go vet ./...` passes with no warnings
3. `grep -r "json:" internal/domain/` returns no results (no struct tags on domain types)
4. `grep -r "import" internal/domain/*.go` shows only standard library imports (time, fmt, errors) — no project-internal or external dependencies
5. Backend interface references domain types correctly (compiles)
6. BackendError.Unwrap() is implemented (enables error chain inspection)
</verification>

<success_criteria>
- Go module `github.com/florianriquelme/sshjesus` initialized with Go 1.24+
- Server struct has all 14 fields specified by user (host, user, port, identity file, proxy, tags, notes, last connected, favorite, display name, VPN required, credential ID, project IDs, ID)
- Project struct has GitRemoteURLs for detection and Name for display
- Credential struct uses CredentialType enum (KeyFile, SSHAgent, Password)
- All domain types have Validate() methods
- Sentinel errors cover all specified failure modes
- BackendError wraps errors with Op + Backend context and supports Unwrap()
- Backend interface is minimal (read + close), Writer adds optional CRUD, Filterer adds optional queries
- Zero struct tags on domain models
- All code compiles and passes `go vet`
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-architecture/01-01-SUMMARY.md`
</output>
