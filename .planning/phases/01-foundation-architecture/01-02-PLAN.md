---
phase: 01-foundation-architecture
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/backend/mock/mock.go
  - internal/backend/mock/mock_test.go
  - internal/config/config.go
  - internal/config/config_test.go
  - internal/domain/validation_test.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "Mock backend implements Backend and Writer interfaces with thread-safe in-memory storage"
    - "Mock backend CRUD operations work correctly for servers, projects, and credentials"
    - "Mock backend returns correct sentinel errors (ErrServerNotFound, ErrBackendUnavailable, etc.)"
    - "Config loading reads TOML from XDG config path and returns typed AppConfig"
    - "Config returns ErrConfigNotFound when no config file exists"
    - "Domain validation rejects invalid inputs (empty host, invalid port, etc.)"
  artifacts:
    - path: "internal/backend/mock/mock.go"
      provides: "Thread-safe in-memory Backend + Writer implementation"
      contains: "type Backend struct"
    - path: "internal/backend/mock/mock_test.go"
      provides: "Comprehensive tests for mock backend CRUD and error paths"
      contains: "func Test"
    - path: "internal/config/config.go"
      provides: "XDG-based TOML config loading and saving"
      contains: "func Load"
    - path: "internal/config/config_test.go"
      provides: "Tests for config loading, saving, and error handling"
      contains: "func Test"
    - path: "internal/domain/validation_test.go"
      provides: "Tests for domain validation methods"
      contains: "func Test"
  key_links:
    - from: "internal/backend/mock/mock.go"
      to: "internal/backend/backend.go"
      via: "implements Backend and Writer interfaces"
      pattern: "backend\\.(Backend|Writer)"
    - from: "internal/backend/mock/mock.go"
      to: "internal/domain/server.go"
      via: "stores and returns domain.Server instances"
      pattern: "domain\\.Server"
    - from: "internal/backend/mock/mock.go"
      to: "internal/errors/errors.go"
      via: "returns sentinel errors on failure"
      pattern: "errors\\.Err(ServerNotFound|BackendUnavailable)"
    - from: "internal/config/config.go"
      to: "internal/errors/errors.go"
      via: "returns ErrConfigNotFound"
      pattern: "errors\\.ErrConfigNotFound"
---

<objective>
Implement the mock backend, config management, and comprehensive tests using TDD for sshjesus.

Purpose: Prove the architecture works end-to-end. The mock backend is the first concrete implementation of the Backend + Writer interfaces, validating the contract design. Config management handles XDG-based TOML loading for backend selection. Tests verify every error path and CRUD operation, giving confidence that future backends (SSH config, 1Password) will slot in cleanly.

Output: Working mock backend with tests, config management with tests, domain validation tests. All tests pass. Architecture is proven.
</objective>

<execution_context>
@/Users/florianriquelme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/florianriquelme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-architecture/01-CONTEXT.md
@.planning/phases/01-foundation-architecture/01-RESEARCH.md
@.planning/phases/01-foundation-architecture/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD — Mock backend with full CRUD and error handling</name>
  <files>
    internal/backend/mock/mock.go
    internal/backend/mock/mock_test.go
    internal/domain/validation_test.go
    go.mod
    go.sum
  </files>
  <action>
    Follow RED-GREEN-REFACTOR cycle:

    **RED phase — write failing tests first:**

    1. Create `internal/domain/validation_test.go` with table-driven tests:
       - TestServerValidate: valid server passes, empty Host fails, Port 0 defaults OK, Port -1 fails, Port 70000 fails, empty DisplayName fails
       - TestProjectValidate: valid project passes, empty Name fails
       - TestCredentialValidate: valid credential passes, empty Name fails, KeyFile type with empty KeyFilePath fails, SSHAgent type with empty KeyFilePath passes (not needed for agent auth)

    2. Create `internal/backend/mock/mock_test.go` with table-driven tests covering:

       **Server CRUD:**
       - TestCreateServer: creates server, retrieves by ID, fields match
       - TestCreateServerDuplicate: second create with same ID returns ErrDuplicateID
       - TestGetServerNotFound: get non-existent ID returns error wrapping ErrServerNotFound
       - TestListServers: list returns all created servers
       - TestListServersEmpty: list on empty backend returns empty slice (not nil)
       - TestUpdateServer: update existing server changes fields
       - TestUpdateServerNotFound: update non-existent returns error wrapping ErrServerNotFound
       - TestDeleteServer: delete removes server, subsequent get returns not found
       - TestDeleteServerNotFound: delete non-existent returns error wrapping ErrServerNotFound

       **Project CRUD (same pattern):**
       - TestCreateProject, TestGetProjectNotFound, TestListProjects, TestUpdateProject, TestDeleteProject

       **Credential CRUD (same pattern):**
       - TestCreateCredential, TestGetCredentialNotFound, TestListCredentials, TestUpdateCredential, TestDeleteCredential

       **Error handling:**
       - TestClosedBackend: after Close(), all operations return ErrBackendUnavailable
       - TestErrorChain: verify errors.Is(err, ErrServerNotFound) works through BackendError wrapper
       - TestErrorAs: verify errors.As(err, &BackendError{}) extracts Op and Backend fields

       **Thread safety:**
       - TestConcurrentAccess: launch 10 goroutines doing concurrent reads and writes, no panics or data races

       **Copy semantics:**
       - TestGetServerReturnsCopy: modify returned server, re-get should return original values
       - TestCreateServerStoresCopy: modify original after create, get should return stored values

       Use `github.com/stretchr/testify/assert` and `github.com/stretchr/testify/require` for assertions. Run `go get github.com/stretchr/testify` first.

    3. Run tests — they MUST fail (mock package doesn't exist yet). Commit: `test(01-02): add failing tests for mock backend and domain validation`

    **GREEN phase — implement to pass:**

    4. Create `internal/backend/mock/mock.go` with `package mock`:
       - `type Backend struct` with:
         - mu sync.RWMutex
         - servers map[string]*domain.Server
         - projects map[string]*domain.Project
         - credentials map[string]*domain.Credential
         - closed bool
       - `func New() *Backend` — initializes all maps
       - Implement ALL Backend interface methods (Get/List for servers, projects, credentials, Close)
       - Implement ALL Writer interface methods (Create/Update/Delete for servers, projects, credentials)
       - Every method: check closed first (return ErrBackendUnavailable), use RLock for reads, Lock for writes
       - All Get methods: return copy (not pointer to stored value) — prevent external mutation
       - All Create methods: store copy (not pointer to argument) — prevent caller mutation affecting store
       - All List methods: return empty slice (not nil) when no items exist
       - Wrap errors in BackendError with Op (method name) and Backend ("mock")
       - `func (b *Backend) Seed(servers []*domain.Server, projects []*domain.Project, credentials []*domain.Credential)` — helper for test setup, stores copies of everything

       Compile-time interface verification:
       ```go
       var _ backend.Backend = (*Backend)(nil)
       var _ backend.Writer = (*Backend)(nil)
       ```

    5. Run all tests — they MUST pass. Commit: `feat(01-02): implement mock backend with CRUD operations`

    **REFACTOR phase (if needed):**

    6. Review for DRY opportunities (e.g., generic copy helpers if Go generics make sense). Run tests again after any refactor. Commit if changes made: `refactor(01-02): clean up mock backend`

    Run tests with race detector: `go test -race ./internal/...`
  </action>
  <verify>
    `go test -race -v ./internal/...` — all tests pass, no data races.
    `go test -cover ./internal/backend/mock/` — coverage should be >90%.
    `go vet ./...` — no warnings.
  </verify>
  <done>
    Mock backend implements Backend + Writer interfaces. All CRUD operations for servers, projects, and credentials work correctly. Error chains work with errors.Is() and errors.As(). Thread-safe under concurrent access (verified by race detector). Copy-on-read and copy-on-write prevent mutation leaks. Domain validation tests pass. Test coverage >90% for mock package.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD — Config management with XDG and TOML</name>
  <files>
    internal/config/config.go
    internal/config/config_test.go
    go.mod
    go.sum
  </files>
  <action>
    Follow RED-GREEN-REFACTOR cycle:

    **RED phase — write failing tests first:**

    1. Create `internal/config/config_test.go` with tests:
       - TestLoadConfigNotFound: loading from non-existent path returns ErrConfigNotFound
       - TestLoadConfigValid: write a valid TOML file to temp dir, load it, verify fields parse correctly
       - TestLoadConfigMalformed: write invalid TOML to temp dir, load it, verify error mentions "malformed"
       - TestSaveConfig: save config to temp dir, read file back, verify TOML content
       - TestSaveAndReload: save then load — round-trip produces identical config
       - TestDefaultConfig: DefaultConfig() returns sensible defaults (empty backend = needs setup)
       - TestConfigValidate: config with empty Backend field returns validation error

       For tests, use `t.TempDir()` to create temporary directories instead of mocking XDG paths. The config functions should accept a path parameter for testability (the public API can default to XDG paths).

    2. Run tests — they MUST fail. Commit: `test(01-02): add failing tests for config management`

    **GREEN phase — implement to pass:**

    3. Install dependencies: `go get github.com/BurntSushi/toml github.com/adrg/xdg`

    4. Create `internal/config/config.go` with `package config`:
       - `type Config struct` with TOML tags:
         - Backend string `toml:"backend"` (backend identifier: "sshconfig", "onepassword", "mock")
         - Add a `toml:"version"` int field for future config migrations (start at 1)
       - `func DefaultConfig() *Config` — returns Config with empty Backend and Version 1
       - `func (c *Config) Validate() error` — Backend must be non-empty (empty = setup wizard needed, but that's deferred to Phase 2+, so for Phase 1 we just return a validation error)
       - `func DefaultPath() (string, error)` — returns `xdg.ConfigFile("sshjesus/config.toml")` (creates dirs if needed)
       - `func Load(path string) (*Config, error)`:
         - If path is empty, use `xdg.SearchConfigFile("sshjesus/config.toml")`; if search fails, return `ErrConfigNotFound` (from internal/errors)
         - If path provided, check file exists; if not, return `ErrConfigNotFound`
         - Decode TOML file into Config struct
         - On decode error, return `fmt.Errorf("malformed config file at %s: %w", path, err)`
       - `func Save(cfg *Config, path string) error`:
         - If path is empty, use `DefaultPath()` to get XDG path
         - Create file, encode Config as TOML
         - Return wrapped errors on failure
       - Per user decision: config file selects one backend at a time. Format is TOML per research recommendation (eliminates indentation bugs, explicit types).
       - Per deferred ideas: NO interactive setup wizard logic here. If config missing, just return ErrConfigNotFound. Phase 2+ handles the wizard.

    5. Run all tests — they MUST pass. Commit: `feat(01-02): implement config management with TOML and XDG`

    **REFACTOR phase (if needed):**

    6. Clean up, ensure error messages are developer-friendly per user decision (technical, surface actual errors). Run tests. Commit if changes made: `refactor(01-02): clean up config management`

    7. Final full test suite: `go test -race -v ./...`
  </action>
  <verify>
    `go test -race -v ./internal/config/` — all tests pass.
    `go test -cover ./internal/config/` — coverage should be >85%.
    `go build ./...` — full module compiles.
    `go vet ./...` — no warnings.
  </verify>
  <done>
    Config management loads/saves TOML config from XDG paths. Config struct has backend field and version for future migrations. Load returns ErrConfigNotFound when file missing, descriptive error when malformed. Save creates directories via XDG. Round-trip (save then load) preserves all fields. No setup wizard logic (deferred per user decision). All tests pass with race detector.
  </done>
</task>

</tasks>

<verification>
1. `go test -race -v ./...` — ALL tests pass across entire module, no data races
2. `go test -cover ./...` — mock backend >90% coverage, config >85% coverage
3. `go build ./...` — entire module compiles
4. `go vet ./...` — no warnings
5. Verify mock backend satisfies both interfaces: compile-time check `var _ backend.Backend = (*Backend)(nil)` and `var _ backend.Writer = (*Backend)(nil)` in mock package
6. Verify error chains: test file confirms `errors.Is(backendErr, ErrServerNotFound)` returns true
7. Verify copy semantics: test file confirms mutations after Get/Create don't leak into stored data
8. Verify config round-trip: save config, load it back, fields match
</verification>

<success_criteria>
- Mock backend implements Backend + Writer with thread-safe in-memory maps
- CRUD for servers, projects, and credentials works correctly
- Error chains work: BackendError wraps sentinel errors, errors.Is()/errors.As() work through chain
- Copy-on-read and copy-on-write prevent mutation leaks
- Concurrent access safe (race detector passes)
- Config loads TOML from XDG paths, returns ErrConfigNotFound when missing
- Config saves TOML, round-trip preserves all fields
- Domain validation catches invalid inputs (empty host, bad port, missing key path)
- All tests pass: `go test -race ./...` exits 0
- No setup wizard or TUI settings logic (deferred per user decision)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-architecture/01-02-SUMMARY.md`
</output>
