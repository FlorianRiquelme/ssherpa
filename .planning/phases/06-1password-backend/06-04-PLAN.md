---
phase: 06-1password-backend
plan: 04
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - internal/backend/multi.go
  - internal/backend/multi_test.go
  - internal/tui/model.go
  - internal/tui/messages.go
  - internal/tui/status_bar.go
  - internal/tui/styles.go
  - cmd/ssherpa/main.go
  - internal/config/config.go
autonomous: true

must_haves:
  truths:
    - "Servers from all active backends merge into one unified list in the TUI"
    - "When a server exists in both ssh-config and 1Password, 1Password version is shown"
    - "TUI shows persistent status bar indicating 1Password availability"
    - "Status bar disappears when 1Password is available, shows warning when locked/unavailable"
    - "main.go initializes correct backend(s) based on config and passes to TUI"
    - "No visual distinction between backend sources in the server list"
  artifacts:
    - path: "internal/backend/multi.go"
      provides: "Multi-backend aggregator that merges servers from multiple backends"
      exports: ["MultiBackend", "NewMultiBackend"]
    - path: "internal/tui/status_bar.go"
      provides: "1Password status bar component for TUI"
      contains: "renderStatusBar"
    - path: "cmd/ssherpa/main.go"
      provides: "Updated entrypoint with multi-backend initialization"
      contains: "onepassword"
  key_links:
    - from: "internal/backend/multi.go"
      to: "internal/backend/backend.go"
      via: "implements Backend interface by aggregating multiple backends"
      pattern: "var _ Backend"
    - from: "internal/tui/model.go"
      to: "internal/backend/onepassword/status.go"
      via: "receives status updates for banner display"
      pattern: "BackendStatus"
    - from: "cmd/ssherpa/main.go"
      to: "internal/backend/onepassword/backend.go"
      via: "initializes 1Password backend from config"
      pattern: "onepassword\\.New"
---

<objective>
Wire everything together: multi-backend aggregator that merges servers from all active backends, TUI status bar for 1Password availability, and main.go initialization logic.

Purpose: This plan bridges the 1Password backend (Plan 01), sync engine (Plan 02), and offline fallback (Plan 03) into the working TUI. Users see a unified server list regardless of source, with clear indicators when 1Password needs attention.

Output: Working end-to-end flow from 1Password to TUI, with multi-backend support and status awareness.
</objective>

<execution_context>
@/Users/florianriquelme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/florianriquelme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-1password-backend/06-RESEARCH.md
@.planning/phases/06-1password-backend/06-01-SUMMARY.md
@.planning/phases/06-1password-backend/06-02-SUMMARY.md
@.planning/phases/06-1password-backend/06-03-SUMMARY.md
@internal/backend/backend.go
@internal/tui/model.go
@internal/tui/messages.go
@internal/tui/styles.go
@cmd/ssherpa/main.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Multi-backend aggregator</name>
  <files>
    internal/backend/multi.go
    internal/backend/multi_test.go
    internal/config/config.go
  </files>
  <action>
**Create `internal/backend/multi.go`:**

```go
// MultiBackend aggregates servers from multiple Backend implementations.
// Implements Backend interface. Delegates writes to the first Writer-capable backend.
type MultiBackend struct {
    backends []Backend
    priority []string // Backend names in priority order (last wins for conflicts)
    mu       sync.RWMutex
}
```

`NewMultiBackend(backends ...Backend) *MultiBackend`:
- Takes backends in priority order (later backends win conflicts)
- Per requirement: 1Password wins over ssh-config, so order is [sshconfig, onepassword]

Implement Backend interface:
- `ListServers(ctx context.Context)` — list from ALL backends, merge into single list. For duplicate DisplayNames, keep the server from the higher-priority backend (later in the list). Use case-insensitive DisplayName comparison for dedup.
- `GetServer(ctx context.Context, id string)` — try backends in reverse priority order (highest first), return first match.
- `ListProjects/GetProject/ListCredentials/GetCredential` — aggregate from all backends (no dedup needed for these).
- `Close()` — close ALL backends (log errors but don't fail on first).

Implement Writer interface (delegate to first Writer-capable backend):
- Check each backend with type assertion `if w, ok := b.(Writer); ok`
- `CreateServer/UpdateServer/DeleteServer` — delegate to first Writer backend
- `CreateProject/UpdateProject/DeleteProject/CreateCredential/UpdateCredential/DeleteCredential` — delegate to first Writer backend

Add a method for status awareness:
- `GetOnePasswordStatus() BackendStatus` — iterate backends, find the onepassword.Backend, return its status. Returns StatusUnknown if no 1P backend.

**Update `internal/config/config.go`:**

Add 1Password-specific config fields:
```go
type OnePasswordConfig struct {
    AccountName string `toml:"account_name"` // For desktop app integration
    CachePath   string `toml:"cache_path,omitempty"` // Override TOML cache path
}
```

Add to Config struct:
```go
OnePassword OnePasswordConfig `toml:"onepassword"` // 1Password backend settings
```

Update `Validate()` to accept "onepassword" as valid backend value (in addition to "sshconfig").
Support `backend = "both"` for multi-backend mode (ssh-config + 1Password simultaneously).

**TDD tests** (`multi_test.go`):
- Use mock backends (from Phase 1 mock package)
- RED: `TestMultiBackend_MergesServers` — backend A has [srv1, srv2], backend B has [srv3] -> ListServers returns 3 servers
- RED: `TestMultiBackend_DeduplicatesByPriority` — backend A has "prod-web", backend B also has "prod-web" -> returns B's version (higher priority)
- RED: `TestMultiBackend_CaseInsensitiveDedup` — "Prod-Web" vs "prod-web" -> dedup applies
- RED: `TestMultiBackend_WriterDelegation` — CreateServer goes to Writer-capable backend
- RED: `TestMultiBackend_CloseAll` — Close calls Close on every backend
- GREEN: Implement to pass
  </action>
  <verify>
Run `go test ./internal/backend/... -v -run TestMulti` — all tests pass.
Run `go build ./...` — project compiles.
  </verify>
  <done>
Multi-backend aggregator merges servers with priority-based deduplication. Writes delegate to first Writer-capable backend. Config supports "onepassword" and "both" backend modes. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: TUI status bar, backend integration in model, and main.go wiring</name>
  <files>
    internal/tui/status_bar.go
    internal/tui/messages.go
    internal/tui/model.go
    internal/tui/styles.go
    cmd/ssherpa/main.go
  </files>
  <action>
**Create `internal/tui/status_bar.go`:**

Render a status bar that shows 1Password availability:
```go
func renderStatusBar(status BackendStatus, width int) string
```

Status rendering rules (per locked decisions):
- `StatusAvailable`: No bar shown (clean UI — no visual distinction between backends)
- `StatusLocked`: Yellow warning bar: "1Password is locked. Unlock the app to sync servers."
- `StatusUnavailable`: Orange warning bar: "1Password is not running. Using cached servers."
- `StatusUnknown`: Gray info bar: "Checking 1Password status..."

Use lipgloss for styling:
- Warning bar: full-width, padded, contrasting text
- Should fit within existing TUI layout (subtract bar height from list height)

**Update `internal/tui/messages.go`:**

Add new message types:
```go
// onePasswordStatusMsg is sent when 1Password status changes.
type onePasswordStatusMsg struct {
    status BackendStatus // From onepassword package
}

// backendServersUpdatedMsg is sent when backend servers are refreshed (e.g., after 1P sync).
type backendServersUpdatedMsg struct{}
```

Import the onepassword package's BackendStatus type, or define a local equivalent to avoid import cycles. Best approach: define status constants in `internal/backend/` (not in `onepassword/`) since the multi-backend also uses them.

Actually, move `BackendStatus` to `internal/backend/status.go` to avoid import cycles:
```go
package backend

type BackendStatus int
const (
    StatusUnknown BackendStatus = iota
    StatusAvailable
    StatusLocked
    StatusUnavailable
)
```

Then the onepassword package and tui package both import from `internal/backend/`.

**Update `internal/tui/model.go`:**

Add fields to Model:
```go
// Phase 6 additions:
opStatus    backend.BackendStatus  // Current 1Password status
opStatusBar string                  // Rendered status bar (cached)
```

Update `New()` function signature to accept backend status callback channel or initial status:
- Add `opStatus backend.BackendStatus` parameter
- The poller's onChange callback will send `onePasswordStatusMsg` to the TUI via `tea.Program.Send()`

Handle new messages in `Update()`:
- `onePasswordStatusMsg`: update `m.opStatus`, re-render status bar
- `backendServersUpdatedMsg`: reload the server list from backend (trigger re-fetch)

Update `View()` for ViewList:
- If `m.opStatus != StatusAvailable && m.opStatus != StatusUnknown`, render status bar between search bar and list
- Subtract status bar height from list height

**Update `cmd/ssherpa/main.go`:**

Replace current single-backend logic with multi-backend initialization:

```go
func main() {
    // Load config
    cfg := loadConfig()

    // Initialize backends based on config
    var backends []backend.Backend

    // SSH config backend (always active)
    sshBackend := initSSHConfigBackend(sshConfigPath)
    backends = append(backends, sshBackend)

    // 1Password backend (if configured)
    var opBackend *onepassword.Backend
    if cfg.Backend == "onepassword" || cfg.Backend == "both" {
        opBackend = init1PasswordBackend(cfg.OnePassword)
        if opBackend != nil {
            backends = append(backends, opBackend)
        }
    }

    // Create multi-backend (or use single if only one)
    multi := backend.NewMultiBackend(backends...)

    // Create TUI with initial status
    initialStatus := backend.StatusUnknown
    if opBackend != nil {
        initialStatus = opBackend.GetStatus()
    }

    model := tui.New(sshConfigPath, historyPath, returnToTUI, currentProjectID, projects, appConfigPath, initialStatus)

    p := tea.NewProgram(model, tea.WithAltScreen())

    // Start 1Password poller (sends status updates to TUI)
    if opBackend != nil {
        opBackend.StartPolling(5*time.Second, func(status backend.BackendStatus) {
            p.Send(tui.OnePasswordStatusMsg{Status: status})
        })

        // Initial sync
        go func() {
            ctx := context.Background()
            if err := opBackend.SyncFromOnePassword(ctx); err != nil {
                opBackend.LoadFromCache()
            }
            // Trigger initial server list refresh
            p.Send(tui.BackendServersUpdatedMsg{})
        }()
    }

    // Run TUI
    if _, err := p.Run(); err != nil { ... }

    // Cleanup
    multi.Close()
}
```

**Key consideration**: The TUI currently loads SSH hosts directly via `sshconfig.ParseSSHConfig()`. With multi-backend, the TUI should receive servers from the multi-backend instead. BUT this is a significant refactor of how servers flow into the TUI. For Phase 6, keep the existing SSH config loading path AND add 1Password servers on top:

1. SSH config hosts load via existing `loadConfigCmd` (unchanged)
2. 1Password servers arrive via `backendServersUpdatedMsg`
3. Model merges both lists in `rebuildListItems()`, with 1P servers winning duplicates
4. This avoids breaking existing functionality while adding 1P support

Update the TUI model's data flow:
- Add `opServers []sshconfig.SSHHost` field — 1P servers converted to SSHHost format for compatibility with existing list/filter logic
- On `backendServersUpdatedMsg`: fetch from multi-backend, convert to SSHHost, store in `opServers`
- Update `allHosts` to be the merge of `sshConfigHosts` (from existing load) + `opServers` (from 1P), with 1P winning duplicates by DisplayName

This approach minimizes changes to existing TUI code while adding multi-backend support.

**Update `internal/tui/styles.go`:**
Add styles for status bar:
- `statusBarWarningStyle` — yellow/orange background, dark text
- `statusBarInfoStyle` — gray background
  </action>
  <verify>
Run `go build ./...` — project compiles with all changes.
Run `go vet ./...` — no vet warnings.
Verify main.go supports both backends: grep for "onepassword" in cmd/ssherpa/main.go.
Verify status bar renders: check status_bar.go has renderStatusBar function.
  </verify>
  <done>
Multi-backend aggregator wired into main.go. TUI shows status bar when 1Password is locked/unavailable. Servers from both backends merge seamlessly with 1Password winning conflicts. Poller sends status updates to TUI. Existing SSH config functionality unchanged.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` — entire project compiles
2. `go test ./internal/backend/... -v` — multi-backend tests pass
3. `go vet ./...` — no warnings
4. Status bar renders correctly for each status
5. Multi-backend deduplication prioritizes 1Password
6. Existing SSH config loading path still works
</verification>

<success_criteria>
- Servers from all backends appear in unified TUI list (no visual source distinction)
- 1Password servers override SSH config servers with same alias
- Status bar shows when 1Password is locked or unavailable
- Status bar hidden when 1Password is available (clean UI)
- main.go initializes correct backends based on config
- Poller status updates reflected in TUI in real-time
- Existing functionality (search, connect, CRUD) continues working
</success_criteria>

<output>
After completion, create `.planning/phases/06-1password-backend/06-04-SUMMARY.md`
</output>
