---
phase: 02-ssh-config-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/sshconfig/parser.go
  - internal/sshconfig/parser_test.go
  - internal/sshconfig/backend.go
  - internal/sshconfig/backend_test.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "SSH config file is parsed into domain-independent host structs with all config options preserved"
    - "Include directives are followed recursively and source file is tracked per host"
    - "Wildcard entries (Host *) are identified and separated from regular hosts"
    - "Malformed or unreadable config entries produce SSHHost structs with ParseError set, not fatal errors"
    - "Match blocks do not crash the parser — they produce a clear error message"
    - "sshconfig backend implements backend.Backend interface (read-only) and converts SSHHost to domain.Server"
  artifacts:
    - path: "internal/sshconfig/parser.go"
      provides: "SSH config parsing wrapper around kevinburke/ssh_config"
      exports: ["SSHHost", "ParseSSHConfig"]
    - path: "internal/sshconfig/parser_test.go"
      provides: "Parser tests covering hosts, wildcards, includes, malformed entries"
      min_lines: 80
    - path: "internal/sshconfig/backend.go"
      provides: "Read-only backend.Backend implementation wrapping parsed SSH config"
      exports: ["Backend", "New"]
    - path: "internal/sshconfig/backend_test.go"
      provides: "Backend tests verifying interface compliance and domain model conversion"
      min_lines: 50
  key_links:
    - from: "internal/sshconfig/parser.go"
      to: "kevinburke/ssh_config"
      via: "ssh_config.Decode"
      pattern: "ssh_config\\.Decode"
    - from: "internal/sshconfig/backend.go"
      to: "internal/backend/backend.go"
      via: "implements backend.Backend"
      pattern: "backend\\.Backend"
    - from: "internal/sshconfig/backend.go"
      to: "internal/domain/server.go"
      via: "converts SSHHost to domain.Server"
      pattern: "domain\\.Server"
---

<objective>
Parse ~/.ssh/config (and Include'd files) into structured host data and expose it through the backend.Backend interface.

Purpose: Provides the data layer that the TUI (Plan 02) will consume. Isolates SSH config parsing behind a clean wrapper so the rest of the codebase never touches kevinburke/ssh_config directly. The backend adapter converts parsed SSH hosts into domain.Server models, enabling the same TUI code to work with any backend.

Output: `internal/sshconfig/` package with parser wrapper and backend adapter, fully tested.
</objective>

<execution_context>
@/Users/florianriquelme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/florianriquelme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ssh-config-integration/02-CONTEXT.md
@.planning/phases/02-ssh-config-integration/02-RESEARCH.md
@.planning/phases/01-foundation-architecture/01-01-SUMMARY.md
@.planning/phases/01-foundation-architecture/01-02-SUMMARY.md

@internal/backend/backend.go
@internal/domain/server.go
@internal/errors/errors.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: SSH config parser wrapper with Include and malformed entry handling</name>
  <files>internal/sshconfig/parser.go, internal/sshconfig/parser_test.go, go.mod, go.sum</files>
  <action>
Install kevinburke/ssh_config v1.4.0 (`go get github.com/kevinburke/ssh_config@v1.4.0`).

Create `internal/sshconfig/parser.go` with:

1. **SSHHost struct** — domain-independent model for a parsed SSH config host:
   - `Name string` — Host pattern from config (e.g., "myserver", "*.example.com")
   - `Hostname string` — HostName directive value
   - `User string` — User directive value
   - `Port string` — Port directive value (string, not int — preserve raw config value; default "22" is NOT injected here, that's a display concern)
   - `IdentityFile []string` — all IdentityFile values (multi-value key)
   - `AllOptions map[string][]string` — every SSH config option set for this host, preserving multi-values
   - `SourceFile string` — absolute path to the config file that defined this host
   - `SourceLine int` — line number in SourceFile where Host directive appears
   - `IsWildcard bool` — true if any pattern contains `*` or `?`
   - `ParseError error` — non-nil if this entry had issues (malformed, unreadable, etc.)

2. **ParseSSHConfig(path string) ([]SSHHost, error)** — main entry point:
   - Open file at path, return wrapped error if file doesn't exist
   - Call `ssh_config.Decode(reader)` to parse
   - If Decode fails (e.g., Match block in file): do NOT return fatal error. Instead, return a single SSHHost with Name set to the file basename, ParseError set to the decode error (with clear message about Match directives if error contains "Match"), and SourceFile set to path. This matches the locked decision: malformed entries shown with warning, not silently skipped.
   - Iterate `cfg.Hosts`, for each host:
     - Skip empty pattern lists (comments-only blocks)
     - Build SSHHost with Name = joined patterns (space-separated)
     - Set IsWildcard = true if any pattern string contains `*` or `?`
     - Extract HostName, User, Port, IdentityFile from KV nodes into named fields
     - Populate AllOptions map with all KV pairs
     - Track SourceFile (the `path` argument) and SourceLine from `host.Pos().Line` if available (kevinburke/ssh_config exposes position on Host entries)
   - Return all hosts (including those with ParseError set)

3. **HandleIncludes** — kevinburke/ssh_config handles Include recursion automatically (up to depth 5). However, when hosts come from included files, we need to track which file they came from. The library's `cfg.Hosts` will contain all hosts from all included files. Use `host.Pos()` to get position info. For included files, the library handles expansion of `~` and glob patterns in Include directives.

   NOTE: The library's automatic Include handling means we may not get per-file source tracking directly from Decode. If the library does not expose which file each host came from (check `host.Pos()` return value), store the top-level config path as SourceFile for all hosts and add a comment noting this limitation. Do NOT hand-roll Include recursion.

4. **containsWildcard(patterns []*ssh_config.Pattern) bool** — helper to check if any pattern contains `*` or `?`.

5. **OrganizeHosts(hosts []SSHHost) (regular, wildcards []SSHHost)** — separate regular hosts from wildcards, sort each group alphabetically by Name (per locked decision). This is a pure function, no I/O.

Tests in `internal/sshconfig/parser_test.go`:
- **TestParseSSHConfig_ValidHosts**: Create temp file with 3 Host blocks (different user/port/hostname combos), verify all fields parsed correctly, AllOptions populated
- **TestParseSSHConfig_WildcardDetection**: Host block with `Host *` and `Host *.example.com` both set IsWildcard=true, regular hosts set IsWildcard=false
- **TestParseSSHConfig_MissingFile**: Non-existent path returns error (not panic)
- **TestParseSSHConfig_EmptyFile**: Empty file returns empty slice, no error
- **TestParseSSHConfig_MalformedFile**: File with invalid syntax returns SSHHost with ParseError set (not a fatal error)
- **TestParseSSHConfig_MultiValueKeys**: Host with multiple IdentityFile directives, verify all captured in IdentityFile slice and AllOptions
- **TestOrganizeHosts**: Mix of regular and wildcard hosts, verify separation and alphabetical sorting within each group

Use testify for assertions (already in go.mod). Use `os.CreateTemp` / `t.TempDir()` for test files.
  </action>
  <verify>
```bash
go test -race -v ./internal/sshconfig/ -run TestParse
go test -race -v ./internal/sshconfig/ -run TestOrganize
go vet ./internal/sshconfig/
```
All tests pass, no race conditions, no vet warnings.
  </verify>
  <done>
SSHHost struct exists with all fields. ParseSSHConfig reads real SSH config files and returns structured hosts. Wildcards detected. Malformed entries captured with ParseError (not fatal). OrganizeHosts separates and sorts. All 7+ tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: sshconfig backend adapter implementing backend.Backend interface</name>
  <files>internal/sshconfig/backend.go, internal/sshconfig/backend_test.go</files>
  <action>
Create `internal/sshconfig/backend.go` with:

1. **Backend struct** — read-only backend.Backend implementation:
   - `hosts []SSHHost` — parsed hosts (stored after construction)
   - `closed bool` — lifecycle tracking
   - `mu sync.RWMutex` — thread safety (consistent with mock backend pattern from Phase 1)

2. **New(configPath string) (*Backend, error)** — constructor:
   - Call ParseSSHConfig(configPath)
   - If error, wrap with "sshconfig backend: %w"
   - Store hosts in Backend struct
   - Return ready-to-use backend

3. **Compile-time interface verification:**
   ```go
   var _ backend.Backend = (*Backend)(nil)
   ```
   The sshconfig backend is read-only — it does NOT implement backend.Writer. This is the database/sql pattern from Phase 1: read-only backends only implement the base Backend interface.

4. **GetServer(ctx, id) (*domain.Server, error)** — find server by ID:
   - ID = SSHHost.Name (the Host pattern is the natural identifier for SSH config entries)
   - Linear search through hosts (config files are small, no index needed)
   - Convert SSHHost to domain.Server:
     - Server.ID = SSHHost.Name
     - Server.Host = SSHHost.Hostname (or SSHHost.Name if Hostname is empty — SSH uses Host as fallback)
     - Server.DisplayName = SSHHost.Name
     - Server.User = SSHHost.User
     - Server.Port = parse SSHHost.Port to int (default 22 if empty or unparseable)
     - Server.IdentityFile = first element of SSHHost.IdentityFile (or empty)
     - Server.Proxy = SSHHost.AllOptions["ProxyJump"] first value (or empty)
     - Server.Tags = empty (SSH config has no tag concept)
     - Server.Notes = fmt.Sprintf("Source: %s:%d", SSHHost.SourceFile, SSHHost.SourceLine)
   - Return ErrServerNotFound if no match
   - Return ErrBackendUnavailable if closed
   - Return copy (copy-on-read pattern from Phase 1)

5. **ListServers(ctx) ([]*domain.Server, error)** — return all hosts as domain.Server:
   - Convert each SSHHost to domain.Server using same logic as GetServer
   - Skip hosts where ParseError != nil (they are informational, not real servers)
   - Actually, reconsider: include ALL hosts including those with ParseError. Set a Notes field indicating the parse error. The TUI will use this to show warning indicators. This matches the locked decision: "Malformed entries shown in the list with a warning indicator."
   - Return empty slice if no hosts (not nil)

6. **GetProject, ListProjects, GetCredential, ListCredentials** — return empty results:
   - SSH config has no concept of projects or credentials
   - ListProjects returns empty slice, ListCredentials returns empty slice
   - GetProject returns ErrProjectNotFound, GetCredential returns ErrCredentialNotFound
   - Wrap all errors with BackendError{Op: "methodName", Backend: "sshconfig", Err: ...}

7. **Close()** — mark as closed, future calls return ErrBackendUnavailable

8. **toServer(host SSHHost) *domain.Server** — private helper for SSHHost -> domain.Server conversion. Use this in both GetServer and ListServers.

Tests in `internal/sshconfig/backend_test.go`:
- **TestBackendNew**: Create temp SSH config file, construct backend, verify no error
- **TestBackendListServers**: Backend with 3 hosts returns 3 domain.Server with correct field mapping
- **TestBackendGetServer**: Get by host name returns correct server
- **TestBackendGetServerNotFound**: Non-existent name returns ErrServerNotFound (verify with errors.Is)
- **TestBackendListProjects_Empty**: Returns empty slice
- **TestBackendGetProject_NotFound**: Returns ErrProjectNotFound
- **TestBackendClosed**: After Close(), all operations return ErrBackendUnavailable
- **TestBackendPortParsing**: Hosts with port "2222", empty port (defaults to 22), and invalid port string
- **TestBackendInterfaceCompliance**: Verify `var _ backend.Backend = (*Backend)(nil)` compiles

Use testify, temp files, and the same error-checking patterns from Phase 1 mock backend tests.
  </action>
  <verify>
```bash
go test -race -v ./internal/sshconfig/ -run TestBackend
go vet ./internal/sshconfig/
go build ./...
```
All backend tests pass, no race conditions, project compiles cleanly.
  </verify>
  <done>
sshconfig.Backend implements backend.Backend (compile-time verified). Converts SSHHost to domain.Server with correct field mapping. Port parsing handles defaults and edge cases. Error wrapping follows Phase 1 BackendError pattern. All 8+ tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
# All sshconfig package tests pass with race detector
go test -race -v ./internal/sshconfig/

# No vet warnings
go vet ./internal/sshconfig/

# Full project compiles
go build ./...

# Coverage check
go test -coverprofile=cover.out ./internal/sshconfig/
go tool cover -func=cover.out | tail -1
```

Expected: 15+ tests pass, coverage > 70%, clean compilation.
</verification>

<success_criteria>
1. SSHHost struct captures all SSH config data including AllOptions, SourceFile, IsWildcard, ParseError
2. ParseSSHConfig handles valid configs, empty files, malformed files, and wildcard detection
3. OrganizeHosts separates wildcards from regular hosts and sorts alphabetically
4. sshconfig.Backend implements backend.Backend interface (compile-time verified)
5. SSHHost -> domain.Server conversion maps all relevant fields correctly
6. Port defaults to 22 when empty or invalid
7. Closed backend returns ErrBackendUnavailable for all operations
8. All tests pass with `go test -race ./internal/sshconfig/`
9. `go build ./...` compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-ssh-config-integration/02-01-SUMMARY.md`
</output>
