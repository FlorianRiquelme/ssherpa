---
phase: 02-ssh-config-integration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/tui/model.go
  - internal/tui/list_view.go
  - internal/tui/detail_view.go
  - internal/tui/styles.go
  - internal/tui/messages.go
  - cmd/sshjesus/main.go
  - go.mod
  - go.sum
autonomous: false

must_haves:
  truths:
    - "User can launch sshjesus and see all connections from ~/.ssh/config in a navigable list"
    - "Server list shows two lines per entry: name + hostname on first line, user/port on second"
    - "Wildcard entries (Host *) appear in a separate section at the bottom of the list"
    - "User can navigate the list with arrow keys (up/down) and see selection highlight"
    - "User can press Enter on a server to see its detail view with ALL SSH config options"
    - "Detail view shows which config file the entry was defined in (source tracking)"
    - "User can press Esc to return from detail view to list view"
    - "Missing or empty ~/.ssh/config shows friendly empty state message"
    - "Loading spinner displays while parsing config files"
    - "Accent colors distinguish structural elements (hostnames, users, ports)"
    - "Malformed entries appear in list with warning indicator"
  artifacts:
    - path: "internal/tui/model.go"
      provides: "Root Bubbletea model with view state machine (list/detail), spinner, window size tracking"
      exports: ["Model", "New"]
    - path: "internal/tui/list_view.go"
      provides: "Custom list item implementing Bubbles list.Item with two-line layout"
      exports: ["hostItem"]
    - path: "internal/tui/detail_view.go"
      provides: "Detail view rendering all SSH config options for selected host"
      min_lines: 40
    - path: "internal/tui/styles.go"
      provides: "Lipgloss style definitions with AdaptiveColor for light/dark terminals"
      min_lines: 20
    - path: "internal/tui/messages.go"
      provides: "Custom Bubbletea messages for async config loading"
      exports: ["configLoadedMsg", "configErrorMsg"]
    - path: "cmd/sshjesus/main.go"
      provides: "Entry point wiring config loader, backend, and TUI together"
      min_lines: 20
  key_links:
    - from: "internal/tui/model.go"
      to: "internal/sshconfig/parser.go"
      via: "SSHHost data for list items"
      pattern: "sshconfig\\.SSHHost"
    - from: "internal/tui/model.go"
      to: "charmbracelet/bubbletea"
      via: "tea.Model interface implementation"
      pattern: "tea\\.Model"
    - from: "internal/tui/list_view.go"
      to: "charmbracelet/bubbles/list"
      via: "list.Item and list.DefaultDelegate"
      pattern: "list\\.Item"
    - from: "cmd/sshjesus/main.go"
      to: "internal/sshconfig/backend.go"
      via: "backend construction from config"
      pattern: "sshconfig\\.New"
    - from: "cmd/sshjesus/main.go"
      to: "internal/config/config.go"
      via: "config.Load for backend selection"
      pattern: "config\\.Load"
---

<objective>
Build the TUI that displays parsed SSH connections in a navigable list with detail view, connecting the sshconfig backend (Plan 01) to a working Bubbletea interface.

Purpose: This is the user-facing deliverable of Phase 2. After this plan, running `sshjesus` shows all SSH connections from `~/.ssh/config` in a styled, navigable TUI with detail views. This is the first time the user sees something on screen.

Output: Working TUI application at `cmd/sshjesus/main.go`, styled list and detail views in `internal/tui/`.
</objective>

<execution_context>
@/Users/florianriquelme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/florianriquelme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ssh-config-integration/02-CONTEXT.md
@.planning/phases/02-ssh-config-integration/02-RESEARCH.md
@.planning/phases/02-ssh-config-integration/02-01-SUMMARY.md

@internal/sshconfig/parser.go
@internal/sshconfig/backend.go
@internal/config/config.go
@internal/backend/backend.go
@internal/domain/server.go
@cmd/sshjesus/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: TUI model, views, styles, and messages</name>
  <files>internal/tui/model.go, internal/tui/list_view.go, internal/tui/detail_view.go, internal/tui/styles.go, internal/tui/messages.go, go.mod, go.sum</files>
  <action>
Install TUI dependencies:
```bash
go get github.com/charmbracelet/bubbletea@latest
go get github.com/charmbracelet/bubbles@latest
go get github.com/charmbracelet/lipgloss@latest
```

Create 5 files in `internal/tui/`:

**1. `styles.go`** — Centralized Lipgloss style definitions:
- Use `lipgloss.AdaptiveColor` for all colors (supports light AND dark terminals, per research anti-pattern guidance)
- Define color palette (Claude's discretion on exact values, but use 2-3 accent colors max):
  - `accentColor` — for hostnames and key structural elements (suggest purple/blue range)
  - `secondaryColor` — for user/port info (suggest muted gray/cyan)
  - `warningColor` — for malformed entry indicators (yellow/amber)
  - `borderColor` — for panel borders
- Define reusable styles:
  - `titleStyle` — for "SSH Connections" title in list
  - `selectedStyle` — for currently selected list item
  - `hostnameStyle` — applies accentColor + bold to hostnames
  - `secondaryStyle` — applies secondaryColor to user/port text
  - `warningStyle` — applies warningColor for parse error indicators
  - `detailHeaderStyle` — bold + accent for detail view header
  - `detailLabelStyle` — for option labels in detail view
  - `detailValueStyle` — for option values in detail view
  - `emptyStateStyle` — italic + muted for empty state message
  - `statusBarStyle` — for bottom help/status text

**2. `messages.go`** — Custom Bubbletea messages:
- `configLoadedMsg` — carries `[]sshconfig.SSHHost` and `error` after async parse
- This message is sent by the async config loading command (fired in Init())

**3. `list_view.go`** — Custom list item for Bubbles list component:
- `hostItem` struct wrapping `sshconfig.SSHHost`
- Implement `list.Item` interface:
  - `FilterValue() string` — return host Name (for future search in Phase 3)
  - `Title() string` — return formatted first line: Name styled with hostnameStyle, then hostname in parentheses. If ParseError is set, prepend warning indicator.
  - `Description() string` — return formatted second line: "User: {user} | Port: {port}". Use "default" if user is empty, "22" if port is empty. If ParseError is set, show the error message instead of user/port.
- Per locked decision: two lines per entry, name + hostname on first, user/port on second.
- Warning indicator for malformed entries: prepend a warning symbol (e.g., "! " or similar ASCII-safe indicator) to the title. Use warningStyle color. (Claude's discretion on exact indicator.)
- `separatorItem` struct — a non-interactive item that renders as "--- Wildcard Entries ---" styled with secondaryColor. Implements list.Item with empty FilterValue (excluded from search).

**4. `detail_view.go`** — Detail view renderer:
- Layout: Claude's discretion. Recommendation from research: full-screen detail view (replace list) is simpler and works at any terminal width. Right-panel split is more desktop-like but requires width management. Choose full-screen replacement for simplicity (user presses Enter, list is replaced by detail, Esc returns to list).
- `renderDetailView(host *sshconfig.SSHHost, width, height int) string` — renders:
  - Header: host Name in detailHeaderStyle, bold
  - Source line: "Defined in: {SourceFile}:{SourceLine}" (per locked decision: source tracking)
  - Separator line
  - Standard fields section: Hostname, User, Port, IdentityFile(s) — each with label in detailLabelStyle, value in detailValueStyle
  - All Options section: iterate AllOptions map, display every key-value pair (per locked decision: detail view shows ALL SSH config options). Sort keys alphabetically for consistency.
  - If ParseError is set: show error message prominently at top with warningStyle
  - Footer: "Press Esc to go back" help text
- If content exceeds terminal height, use a `viewport.Model` from Bubbles for scrolling. Import and initialize viewport in model.go, use it here when viewMode == ViewDetail.

**5. `model.go`** — Root Bubbletea model:
- `ViewMode` enum: `ViewList`, `ViewDetail`
- `Model` struct:
  - `viewMode ViewMode`
  - `list list.Model` — Bubbles list component
  - `viewport viewport.Model` — for scrollable detail view
  - `detailHost *sshconfig.SSHHost` — currently selected host for detail view
  - `spinner spinner.Model` — loading spinner
  - `loading bool` — true during config parse
  - `configPath string` — path to SSH config (for async loading)
  - `hosts []sshconfig.SSHHost` — parsed hosts (kept for detail view access)
  - `err error` — parse error to display
  - `width, height int` — terminal dimensions
  - `ready bool` — true after first WindowSizeMsg (needed before setting list size)

- `New(configPath string) Model` — constructor:
  - Initialize spinner (spinner.Dot style)
  - Initialize empty list with title "SSH Connections"
  - Set loading = true
  - Store configPath

- `Init() tea.Cmd` — return `tea.Batch(m.spinner.Tick, loadConfigCmd(m.configPath))`:
  - `loadConfigCmd(path string) tea.Cmd` — returns a function that calls `sshconfig.ParseSSHConfig(path)`, then `sshconfig.OrganizeHosts(hosts)`, builds list items (regular hosts + separator + wildcard hosts per locked decision), and returns `configLoadedMsg{hosts, items, err}`

- `Update(msg tea.Msg) (tea.Model, tea.Cmd)`:
  - `tea.WindowSizeMsg` — update width/height, set list size (subtract space for title and status bar), mark ready=true. Also update viewport dimensions if in detail mode.
  - `configLoadedMsg` — set loading=false, store hosts, set list items (with wildcard section at bottom per locked decision), store error if any
  - `spinner.TickMsg` — delegate to spinner if loading
  - `tea.KeyMsg`:
    - If loading: ignore keys (except ctrl+c/q for quit)
    - If ViewList:
      - `enter` — if selected item is a hostItem (not separator), switch to ViewDetail, set detailHost, initialize viewport with rendered detail content
      - `q` or `ctrl+c` — tea.Quit
      - All other keys: delegate to list component (handles arrow keys, pgup/pgdn, home/end automatically)
    - If ViewDetail:
      - `esc` or `q` — switch back to ViewList, clear detailHost
      - Arrow keys (up/down) — delegate to viewport for scrolling
      - `ctrl+c` — tea.Quit

- `View() string`:
  - If loading: center spinner + "Loading SSH config..." text
  - If err != nil and no hosts loaded: show error message with guidance
  - If no hosts (empty config): show friendly empty state (per locked decision):
    ```
    No SSH connections found

    Create or edit ~/.ssh/config with Host entries:

      Host myserver
        HostName example.com
        User username
        Port 22

    Press 'q' to quit
    ```
  - If ViewList: return list.View()
  - If ViewDetail: return renderDetailView(detailHost, width, height) — rendered through viewport if content is scrollable

- Handle the delegate for list items: use `list.NewDefaultDelegate()` and customize styles to use our accent colors. Set delegate ShowDescription to true (we need the second line). Customize spacing to show two-line items clearly.
  </action>
  <verify>
```bash
go build ./internal/tui/
go vet ./internal/tui/
go build ./...
```
All TUI code compiles cleanly. No vet warnings. Full project builds.
  </verify>
  <done>
TUI package exists with model.go (state machine), list_view.go (two-line items), detail_view.go (all options + source), styles.go (adaptive colors), messages.go (async loading). Compiles cleanly. List shows name+hostname/user+port layout. Detail shows all SSH options and source file. Empty state and loading spinner implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire main.go to load config, create backend, and launch TUI</name>
  <files>cmd/sshjesus/main.go</files>
  <action>
Update `cmd/sshjesus/main.go` to wire everything together:

1. **Config loading** (integrate with Phase 1 config system per locked decision):
   - Try `config.Load("")` to load from XDG path
   - If ErrConfigNotFound: that's OK for Phase 2 — default to "sshconfig" backend (SSH config is the natural default when no config exists yet)
   - If other error: print error and exit
   - If config loaded and Backend == "sshconfig" (or empty): proceed with SSH config backend
   - If config loaded and Backend is something else: print message "Backend '{name}' not yet supported. Using sshconfig." and proceed (other backends are Phase 6+)

2. **Determine SSH config path**:
   - Default: `~/.ssh/config` (use `os.UserHomeDir()` + `filepath.Join`)
   - Could support `--config` flag later, but for now just use default

3. **Launch TUI**:
   - Create `tui.New(sshConfigPath)` model
   - Run `tea.NewProgram(model, tea.WithAltScreen())` — use alt screen so TUI doesn't pollute terminal history
   - If program returns error, print and exit with code 1

4. **Keep it minimal** — no flag parsing, no backend construction in main (TUI handles async loading internally via configLoadedMsg). Main just determines the config path and hands it to the TUI.

The flow is:
```
main.go -> config.Load -> determine ssh config path -> tui.New(path) -> tea.Run
                                                         |
                                                    Init() fires loadConfigCmd
                                                         |
                                                    ParseSSHConfig(path) runs async
                                                         |
                                                    configLoadedMsg -> list populated
```
  </action>
  <verify>
```bash
go build -o /tmp/sshjesus ./cmd/sshjesus/
# Should compile successfully

# Quick smoke test (will show TUI if ~/.ssh/config exists, empty state if not)
# Can't fully verify TUI in CI, but compilation proves wiring is correct
go vet ./cmd/sshjesus/
```
Binary compiles. Vet passes.
  </verify>
  <done>
Running `go run ./cmd/sshjesus/` launches a TUI that reads ~/.ssh/config (if present), shows loading spinner, then displays server list with two-line entries. Missing config shows friendly empty state. Enter opens detail view, Esc returns to list, q quits.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify TUI displays SSH connections correctly</name>
  <what-built>
Complete TUI application that parses ~/.ssh/config and displays all SSH connections in a navigable list with detail views. This is the first user-facing screen of sshjesus.
  </what-built>
  <how-to-verify>
1. Build and run: `go run ./cmd/sshjesus/`
2. **List view**: Verify you see your SSH connections from ~/.ssh/config
   - Each entry should show two lines: name + hostname on first, user/port on second
   - Entries should be sorted alphabetically
   - If you have wildcard entries (Host *), they should appear in a separate section at the bottom
   - If any entries have parse issues, they should show a warning indicator
3. **Navigation**: Use arrow keys (up/down) to move through the list. Selection should be highlighted.
4. **Detail view**: Press Enter on a server entry
   - Should show ALL SSH config options for that host
   - Should show which config file the entry was defined in
   - Press Esc to return to list
5. **Empty state**: If you want to test empty state, temporarily rename your config: `mv ~/.ssh/config ~/.ssh/config.bak`, run sshjesus, then restore: `mv ~/.ssh/config.bak ~/.ssh/config`
6. **Colors**: Hostnames, users, ports should use distinct accent colors (not monochrome)
7. **Quit**: Press q to exit cleanly
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with the TUI</resume-signal>
</task>

</tasks>

<verification>
```bash
# Full test suite passes
go test -race -v ./...

# Full project compiles
go build ./...

# Binary runs (quick check)
go build -o /tmp/sshjesus ./cmd/sshjesus/ && echo "Build OK"

# No vet warnings anywhere
go vet ./...
```
</verification>

<success_criteria>
1. `go run ./cmd/sshjesus/` launches a TUI showing SSH connections from ~/.ssh/config
2. List shows two-line entries: name+hostname / user+port (per locked decision)
3. Wildcard entries (Host *) appear in separate section at bottom (per locked decision)
4. Arrow keys navigate, Enter opens detail view, Esc returns to list
5. Detail view shows ALL SSH config options and source file location (per locked decision)
6. Missing/empty config shows friendly empty state with guidance (per locked decision)
7. Loading spinner shows during config parse (per locked decision)
8. Accent colors distinguish structural elements (per locked decision)
9. Malformed entries show warning indicator (per locked decision)
10. All existing tests still pass: `go test -race ./...`
11. `go build ./...` compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-ssh-config-integration/02-02-SUMMARY.md`
</output>
