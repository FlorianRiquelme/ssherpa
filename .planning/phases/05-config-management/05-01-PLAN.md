---
phase: 05-config-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/sshconfig/writer.go
  - internal/sshconfig/writer_test.go
  - internal/sshconfig/backup.go
  - internal/sshconfig/backup_test.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "SSH config writer can add a new Host block at end of file"
    - "SSH config writer can edit a single Host block without changing other blocks"
    - "SSH config writer can delete a specific Host block"
    - "All comments, blank lines, and indentation in untouched blocks are preserved exactly"
    - "A backup file (~/.ssh/config.bak) is created before every write"
    - "Writes are atomic (partial writes never corrupt the config)"
    - "Hosts from Include files are read-only (writes go to main config only)"
  artifacts:
    - path: "internal/sshconfig/writer.go"
      provides: "SSH config read-write operations with formatting preservation"
      exports: ["AddHost", "EditHost", "RemoveHost", "HostEntry"]
    - path: "internal/sshconfig/writer_test.go"
      provides: "Tests for SSH config writer"
      min_lines: 150
    - path: "internal/sshconfig/backup.go"
      provides: "Backup creation and atomic file write utilities"
      exports: ["CreateBackup", "AtomicWrite"]
    - path: "internal/sshconfig/backup_test.go"
      provides: "Tests for backup and atomic write"
      min_lines: 50
  key_links:
    - from: "internal/sshconfig/writer.go"
      to: "internal/sshconfig/backup.go"
      via: "CreateBackup + AtomicWrite called before/during every write"
      pattern: "CreateBackup|AtomicWrite"
    - from: "internal/sshconfig/writer.go"
      to: "~/.ssh/config"
      via: "File read/parse/write cycle"
      pattern: "os\\.Open|os\\.ReadFile|renameio"
---

<objective>
SSH config file writer with formatting-preserving add/edit/delete operations, backup, and atomic writes.

Purpose: This is the data layer for Phase 5. All TUI CRUD operations need a reliable way to modify ~/.ssh/config without corrupting it. The writer must preserve all comments, blank lines, and indentation in untouched Host blocks, create backups before destructive operations, and use atomic writes to prevent corruption.

Output: `internal/sshconfig/writer.go` (add/edit/delete Host blocks), `internal/sshconfig/backup.go` (backup + atomic write), plus comprehensive tests.
</objective>

<execution_context>
@/Users/florianriquelme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/florianriquelme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-config-management/05-CONTEXT.md
@.planning/phases/05-config-management/05-RESEARCH.md
@internal/sshconfig/parser.go
@internal/sshconfig/backend.go
@internal/domain/server.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backup and atomic write utilities</name>
  <files>internal/sshconfig/backup.go, internal/sshconfig/backup_test.go, go.mod, go.sum</files>
  <action>
Create `internal/sshconfig/backup.go` with two utilities:

1. `CreateBackup(configPath string) error` - Copies configPath to configPath + ".bak", overwriting any existing backup. Uses `os.ReadFile` + `os.WriteFile` with same permissions as original. Returns error if source doesn't exist.

2. `AtomicWrite(path string, data []byte, perm os.FileMode) error` - Uses `google/renameio` (v2) to write data atomically: writes to temp file in same directory, then renames. This prevents partial writes from corrupting the config. Signature: accepts path, data bytes, and file permissions.

Add `github.com/google/renameio/v2` to go.mod via `go get github.com/google/renameio/v2`.

Create `internal/sshconfig/backup_test.go` with tests:
- TestCreateBackup_CreatesBackupFile - verifies .bak file has same content as original
- TestCreateBackup_OverwritesExisting - verifies existing .bak is replaced
- TestCreateBackup_SourceNotFound - verifies error on missing file
- TestAtomicWrite_WritesFile - verifies file written with correct content
- TestAtomicWrite_AtomicOnError - verifies partial writes don't leave corrupt files (use temp dir for isolation)

Use testify/assert. All tests use `t.TempDir()` for isolation.
  </action>
  <verify>`go test -race -v ./internal/sshconfig/... -run TestCreateBackup` and `go test -race -v ./internal/sshconfig/... -run TestAtomicWrite` pass. `go vet ./internal/sshconfig/` clean.</verify>
  <done>CreateBackup copies config to .bak, AtomicWrite writes files without corruption risk, all tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: SSH config writer with formatting preservation</name>
  <files>internal/sshconfig/writer.go, internal/sshconfig/writer_test.go</files>
  <action>
Create `internal/sshconfig/writer.go` with a text-based approach for format-preserving SSH config manipulation. Do NOT use kevinburke/ssh_config for writing (it doesn't support write operations). Instead, use line-by-line text manipulation to preserve formatting.

**Strategy:** Read the SSH config file as raw text lines. Identify Host block boundaries (a Host block starts with a line matching `^Host\s+` or `^host\s+` and extends until the next `Host` line or EOF). Manipulate specific blocks while leaving everything else untouched.

**Types:**

```go
// HostEntry represents an SSH config host entry for add/edit operations.
type HostEntry struct {
    Alias        string            // Host alias (the name after "Host")
    Hostname     string            // HostName directive value
    User         string            // User directive value
    Port         string            // Port directive value (empty = omit, use SSH default 22)
    IdentityFile string            // IdentityFile path (empty = omit)
    ExtraConfig  string            // Free-text extra SSH directives (multi-line, e.g. "ProxyJump bastion\nForwardAgent yes")
}
```

**Functions:**

1. `AddHost(configPath string, entry HostEntry) error`:
   - Call `CreateBackup(configPath)` first
   - Read file contents
   - Check for duplicate alias (case-insensitive scan for `Host <alias>`) across main file content. If found, return `fmt.Errorf("host alias %q already exists", entry.Alias)`
   - Build the new Host block as text lines with consistent 4-space indentation:
     ```
     Host <alias>
         HostName <hostname>
         User <user>
         Port <port>          # only if non-empty
         IdentityFile <path>  # only if non-empty
         <extra lines>        # each line from ExtraConfig, indented with 4 spaces
     ```
   - Append to end of file with a blank line separator before the new block
   - Write via `AtomicWrite`

2. `EditHost(configPath string, originalAlias string, entry HostEntry) error`:
   - Call `CreateBackup(configPath)` first
   - Read file, find the block for `originalAlias` (match `Host originalAlias` line)
   - If alias changed, check new alias doesn't conflict with another existing host
   - Replace ONLY that block's lines with the new entry (same format as AddHost)
   - Preserve everything outside that block (comments, blank lines, other hosts) exactly as-is
   - Write via `AtomicWrite`

3. `RemoveHost(configPath string, alias string) ([]string, error)`:
   - Call `CreateBackup(configPath)` first
   - Read file, find and remove the block for `alias`
   - Return the removed block lines (for undo buffer)
   - Preserve everything else exactly
   - Write via `AtomicWrite`

**Block boundary detection:** A Host block starts at a line matching `^\s*Host\s+\S+` (case-insensitive) and ends at the line before the next `^\s*Host\s+` or at EOF. The block includes any blank lines and comments that are indented (belong to the block), but NOT unindented comments/blank lines between blocks (those belong to the file structure).

Specifically for block boundaries: a block includes lines from the Host directive until (but not including) the next unindented non-blank, non-comment line that starts a new block. Blank lines between blocks should be preserved as-is.

**Important:** This approach works on raw text lines, so ALL formatting (comments, indentation, blank lines) outside the target block is preserved byte-for-byte.

Create `internal/sshconfig/writer_test.go` with tests using temp files:

- TestAddHost_AppendsToEnd - new block at end, existing content unchanged
- TestAddHost_DuplicateAlias - returns error for existing alias
- TestAddHost_PreservesComments - comments in existing file untouched
- TestAddHost_AllFields - all HostEntry fields rendered correctly
- TestAddHost_MinimalFields - only required fields (alias, hostname, user)
- TestAddHost_WithExtraConfig - ExtraConfig lines properly indented
- TestAddHost_CreatesBackup - .bak file exists after add
- TestEditHost_ChangesOnlyTargetBlock - other blocks byte-identical
- TestEditHost_PreservesComments - comments above/below target block preserved
- TestEditHost_AliasChange - alias can be renamed if no conflict
- TestEditHost_AliasConflict - returns error if new alias conflicts
- TestRemoveHost_RemovesBlock - target block gone, rest preserved
- TestRemoveHost_ReturnsLines - removed lines returned for undo
- TestRemoveHost_LastBlock - removing last block in file works
- TestRemoveHost_HostNotFound - returns error for non-existent host

Use testify/assert and require. Each test creates a temp file with known SSH config content, runs the operation, and verifies the result by reading the file back.
  </action>
  <verify>`go test -race -v ./internal/sshconfig/... -run "TestAddHost|TestEditHost|TestRemoveHost"` all pass. `go vet ./internal/sshconfig/` clean. `go build ./...` succeeds.</verify>
  <done>Writer correctly adds, edits, and removes Host blocks while preserving formatting. Backup created before every write. Atomic writes prevent corruption. All 15+ tests pass.</done>
</task>

</tasks>

<verification>
1. `go test -race -v ./internal/sshconfig/...` - all existing parser tests PLUS new writer/backup tests pass
2. `go build ./...` - full project compiles cleanly
3. `go vet ./...` - no warnings
4. Manual verification: create a temp SSH config with comments and multiple hosts, run AddHost/EditHost/RemoveHost, verify untouched sections are byte-identical
</verification>

<success_criteria>
- Writer can add Host blocks at end of file with proper formatting
- Writer can edit a single Host block without touching any other content
- Writer can remove a Host block and return the removed lines
- Comments, blank lines, and indentation in untouched blocks are preserved exactly
- Backup (.bak) is created before every write operation
- Atomic writes ensure no partial corruption
- Duplicate alias detection works for add and edit-rename
- 15+ tests pass with race detector
- All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-config-management/05-01-SUMMARY.md`
</output>
