package sync

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/google/renameio/v2/maybe"

	"github.com/florianriquelme/ssherpa/internal/domain"
)

// WriteSSHIncludeFile generates valid SSH config content from servers and writes
// it atomically to the specified include file path.
//
// The generated file includes:
// - Header comment with timestamp
// - Host blocks for each server with appropriate SSH config directives
// - Blank lines between blocks for readability
//
// Default includePath: ~/.ssh/ssherpa_config
func WriteSSHIncludeFile(servers []*domain.Server, includePath string) error {
	// Build the content
	var content strings.Builder

	// Write header
	content.WriteString("# Generated by ssherpa - DO NOT EDIT MANUALLY\n")
	content.WriteString("# Source: 1Password\n")
	content.WriteString(fmt.Sprintf("# Last sync: %s\n", time.Now().UTC().Format(time.RFC3339)))
	content.WriteString("\n")

	// Write Host blocks
	for i, server := range servers {
		// Add blank line between blocks (but not before the first one)
		if i > 0 {
			content.WriteString("\n")
		}

		// Host directive with DisplayName as alias
		content.WriteString(fmt.Sprintf("Host %s\n", server.DisplayName))

		// Required fields
		content.WriteString(fmt.Sprintf("    HostName %s\n", server.Host))
		content.WriteString(fmt.Sprintf("    User %s\n", server.User))

		// Optional fields (only include if non-default/non-empty)
		if server.Port != 0 && server.Port != 22 {
			content.WriteString(fmt.Sprintf("    Port %d\n", server.Port))
		}

		if server.IdentityFile != "" {
			content.WriteString(fmt.Sprintf("    IdentityFile %s\n", server.IdentityFile))
		}

		if server.Proxy != "" {
			content.WriteString(fmt.Sprintf("    ProxyJump %s\n", server.Proxy))
		}

		// ForwardAgent based on tags or notes (convention)
		// Check if server has "forwardagent" tag or mentions it in notes
		if hasForwardAgent(server) {
			content.WriteString("    ForwardAgent yes\n")
		}
	}

	// Write atomically with renameio (ensures 0600 permissions)
	if err := maybe.WriteFile(includePath, []byte(content.String()), 0600); err != nil {
		return fmt.Errorf("write SSH include file: %w", err)
	}

	return nil
}

// hasForwardAgent checks if a server should have ForwardAgent enabled.
// This checks for a "forwardagent" tag (case-insensitive) or mentions in notes.
func hasForwardAgent(server *domain.Server) bool {
	// Check tags
	for _, tag := range server.Tags {
		if strings.EqualFold(tag, "forwardagent") {
			return true
		}
	}

	// Check notes (case-insensitive)
	if strings.Contains(strings.ToLower(server.Notes), "forwardagent") {
		return true
	}

	return false
}

// EnsureIncludeDirective ensures that the SSH config file contains an Include
// directive pointing to the ssherpa include file.
//
// If the file doesn't exist, it creates it with the Include directive.
// If the file exists but doesn't have the Include, it prepends it.
// If the Include already exists (case-insensitive), it's a no-op.
//
// The Include directive is prepended (not appended) because SSH config uses
// first-match-wins semantics. If "Host *" appears before the Include, 1Password
// servers won't match.
func EnsureIncludeDirective(sshConfigPath, includePath string) error {
	// Read existing content (or empty if file doesn't exist)
	var existingContent string
	content, err := os.ReadFile(sshConfigPath)
	if err != nil {
		if !os.IsNotExist(err) {
			return fmt.Errorf("read SSH config: %w", err)
		}
		// File doesn't exist - will be created
		existingContent = ""
	} else {
		existingContent = string(content)
	}

	// Check if Include directive already exists (case-insensitive)
	includeDirective := "Include " + includePath
	if hasIncludeDirective(existingContent, includePath) {
		// Already present - no-op
		return nil
	}

	// Build new content with Include prepended
	var newContent strings.Builder

	// Add Include directive at the top
	newContent.WriteString("# ssherpa 1Password integration\n")
	newContent.WriteString(includeDirective)
	newContent.WriteString("\n")

	// Add existing content
	if existingContent != "" {
		// Ensure there's a blank line separator
		newContent.WriteString("\n")
		newContent.WriteString(existingContent)
	}

	// Write atomically with renameio
	if err := maybe.WriteFile(sshConfigPath, []byte(newContent.String()), 0600); err != nil {
		return fmt.Errorf("write SSH config: %w", err)
	}

	return nil
}

// hasIncludeDirective checks if the SSH config content contains an Include
// directive for the specified path (case-insensitive).
func hasIncludeDirective(content, includePath string) bool {
	lines := strings.Split(content, "\n")

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		trimmedLower := strings.ToLower(trimmed)

		// Check for "Include <path>" (case-insensitive)
		if strings.HasPrefix(trimmedLower, "include ") {
			// Extract the path part
			parts := strings.Fields(trimmed)
			if len(parts) >= 2 {
				pathPart := strings.ToLower(parts[1])
				if pathPart == strings.ToLower(includePath) {
					return true
				}
			}
		}
	}

	return false
}
