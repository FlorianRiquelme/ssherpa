package sync

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/florianriquelme/ssherpa/internal/domain"
	"github.com/florianriquelme/ssherpa/internal/sshconfig"
)

// Conflict represents a naming conflict between 1Password and SSH config.
type Conflict struct {
	Alias      string         // The SSH host alias
	OnePassword *domain.Server // Server from 1Password
	SSHConfig   *domain.Server // Server from user's SSH config
	Winner      string         // Always "onepassword" per requirement
}

// DetectConflicts finds conflicts between 1Password servers and user's SSH config.
// A conflict occurs when the same alias (DisplayName) exists in both sources.
//
// Per requirements: 1Password always wins conflicts.
//
// Entries from the sshjesus_config include file are excluded from conflict detection
// (they're generated by sshjesus itself, so they're not real conflicts).
func DetectConflicts(onePasswordServers []*domain.Server, sshConfigPath string) ([]Conflict, error) {
	// Parse user's SSH config
	sshHosts, err := sshconfig.ParseSSHConfig(sshConfigPath)
	if err != nil {
		return nil, fmt.Errorf("parse SSH config: %w", err)
	}

	// Build a map of SSH config hosts (case-insensitive keys)
	// Exclude entries from sshjesus_config (check if they have the sshjesus header comment nearby)
	sshHostMap := make(map[string]*domain.Server)
	for _, host := range sshHosts {
		// Skip if this host is from sshjesus_config
		// We can detect this by checking if SourceFile contains "sshjesus_config"
		// or by checking for the header comment marker
		if isSshjesusGenerated(host) {
			continue
		}

		// Convert SSHHost to domain.Server for comparison
		srv := sshHostToDomainServer(host)
		
		// Use lowercase alias as key for case-insensitive matching
		aliasLower := strings.ToLower(host.Name)
		sshHostMap[aliasLower] = srv
	}

	// Find conflicts
	var conflicts []Conflict
	for _, onepServer := range onePasswordServers {
		aliasLower := strings.ToLower(onepServer.DisplayName)
		
		if sshServer, exists := sshHostMap[aliasLower]; exists {
			// Conflict found
			conflict := Conflict{
				Alias:       onepServer.DisplayName,
				OnePassword: onepServer,
				SSHConfig:   sshServer,
				Winner:      "onepassword",
			}
			conflicts = append(conflicts, conflict)
		}
	}

	return conflicts, nil
}

// isSshjesusGenerated checks if an SSH host entry was generated by sshjesus.
// We detect this by checking if the SourceFile path contains "sshjesus_config".
func isSshjesusGenerated(host sshconfig.SSHHost) bool {
	return strings.Contains(host.SourceFile, "sshjesus_config")
}

// sshHostToDomainServer converts an SSHHost to a domain.Server.
func sshHostToDomainServer(host sshconfig.SSHHost) *domain.Server {
	srv := &domain.Server{
		DisplayName: host.Name,
		Host:        host.Hostname,
		User:        host.User,
		Port:        22, // Default
	}

	// Parse port if present
	if host.Port != "" {
		if port, err := strconv.Atoi(host.Port); err == nil {
			srv.Port = port
		}
	}

	// Use first IdentityFile if present
	if len(host.IdentityFile) > 0 {
		srv.IdentityFile = host.IdentityFile[0]
	}

	// Check for ProxyJump in AllOptions
	if proxyValues, exists := host.AllOptions["ProxyJump"]; exists && len(proxyValues) > 0 {
		srv.Proxy = proxyValues[0]
	}

	return srv
}
