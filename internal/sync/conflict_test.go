package sync

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/florianriquelme/ssherpa/internal/domain"
)

func TestDetectConflicts_NoConflicts(t *testing.T) {
	// Create temp directory for test
	tmpDir := t.TempDir()
	sshConfigPath := filepath.Join(tmpDir, "config")

	// Create SSH config with different host names
	sshConfig := `Host myserver
    HostName example.com
    User admin

Host another
    HostName another.com
    User user
`
	err := os.WriteFile(sshConfigPath, []byte(sshConfig), 0600)
	require.NoError(t, err)

	// Create 1Password servers with different names
	onePasswordServers := []*domain.Server{
		{
			ID:          "srv-001",
			DisplayName: "prod-web",
			Host:        "prod.example.com",
			User:        "deploy",
			Port:        22,
		},
		{
			ID:          "srv-002",
			DisplayName: "staging-api",
			Host:        "staging.example.com",
			User:        "ubuntu",
			Port:        22,
		},
	}

	// Detect conflicts
	conflicts, err := DetectConflicts(onePasswordServers, sshConfigPath)
	require.NoError(t, err)

	// Verify no conflicts
	assert.Len(t, conflicts, 0, "Expected no conflicts when aliases are different")
}

func TestDetectConflicts_OneConflict(t *testing.T) {
	// Create temp directory for test
	tmpDir := t.TempDir()
	sshConfigPath := filepath.Join(tmpDir, "config")

	// Create SSH config with "prod-web" host
	sshConfig := `Host prod-web
    HostName old.example.com
    User olduser

Host myserver
    HostName example.com
    User admin
`
	err := os.WriteFile(sshConfigPath, []byte(sshConfig), 0600)
	require.NoError(t, err)

	// Create 1Password servers, one with same name
	onePasswordServers := []*domain.Server{
		{
			ID:          "srv-001",
			DisplayName: "prod-web",
			Host:        "new.example.com",
			User:        "deploy",
			Port:        22,
		},
		{
			ID:          "srv-002",
			DisplayName: "staging-api",
			Host:        "staging.example.com",
			User:        "ubuntu",
			Port:        22,
		},
	}

	// Detect conflicts
	conflicts, err := DetectConflicts(onePasswordServers, sshConfigPath)
	require.NoError(t, err)

	// Verify one conflict found
	require.Len(t, conflicts, 1, "Expected one conflict")

	conflict := conflicts[0]
	assert.Equal(t, "prod-web", conflict.Alias)
	assert.Equal(t, "onepassword", conflict.Winner)
	assert.NotNil(t, conflict.OnePassword)
	assert.NotNil(t, conflict.SSHConfig)

	// Verify 1Password server details
	assert.Equal(t, "new.example.com", conflict.OnePassword.Host)
	assert.Equal(t, "deploy", conflict.OnePassword.User)

	// Verify SSH config server details
	assert.Equal(t, "old.example.com", conflict.SSHConfig.Host)
	assert.Equal(t, "olduser", conflict.SSHConfig.User)
}

func TestDetectConflicts_CaseInsensitive(t *testing.T) {
	// Create temp directory for test
	tmpDir := t.TempDir()
	sshConfigPath := filepath.Join(tmpDir, "config")

	// Create SSH config with "prod-web" (lowercase)
	sshConfig := `Host prod-web
    HostName old.example.com
    User olduser
`
	err := os.WriteFile(sshConfigPath, []byte(sshConfig), 0600)
	require.NoError(t, err)

	// Create 1Password server with "Prod-Web" (different case)
	onePasswordServers := []*domain.Server{
		{
			ID:          "srv-001",
			DisplayName: "Prod-Web",
			Host:        "new.example.com",
			User:        "deploy",
			Port:        22,
		},
	}

	// Detect conflicts
	conflicts, err := DetectConflicts(onePasswordServers, sshConfigPath)
	require.NoError(t, err)

	// Verify conflict detected despite case difference
	require.Len(t, conflicts, 1, "Expected conflict to be detected (case-insensitive)")
	assert.Equal(t, "Prod-Web", conflicts[0].Alias)
	assert.Equal(t, "onepassword", conflicts[0].Winner)
}

func TestDetectConflicts_ExcludesSshjesusConfig(t *testing.T) {
	// Create temp directory for test
	tmpDir := t.TempDir()
	sshConfigPath := filepath.Join(tmpDir, "config")
	ssherpaConfigPath := filepath.Join(tmpDir, "ssherpa_config")

	// Create ssherpa include file with 1Password servers
	ssherpaConfig := `# Generated by ssherpa - DO NOT EDIT MANUALLY
# Source: 1Password

Host prod-web
    HostName prod.example.com
    User deploy
`
	err := os.WriteFile(ssherpaConfigPath, []byte(ssherpaConfig), 0600)
	require.NoError(t, err)

	// Create main SSH config with Include directive
	sshConfig := `Include ` + ssherpaConfigPath + `

Host myserver
    HostName example.com
    User admin
`
	err = os.WriteFile(sshConfigPath, []byte(sshConfig), 0600)
	require.NoError(t, err)

	// Create 1Password server with same name as in ssherpa_config
	onePasswordServers := []*domain.Server{
		{
			ID:          "srv-001",
			DisplayName: "prod-web",
			Host:        "prod.example.com",
			User:        "deploy",
			Port:        22,
		},
	}

	// Detect conflicts
	conflicts, err := DetectConflicts(onePasswordServers, sshConfigPath)
	require.NoError(t, err)

	// Verify no conflicts (ssherpa_config entries should be excluded)
	assert.Len(t, conflicts, 0, "Expected no conflicts when server only exists in ssherpa_config")
}

func TestDetectConflicts_MultipleConflicts(t *testing.T) {
	// Create temp directory for test
	tmpDir := t.TempDir()
	sshConfigPath := filepath.Join(tmpDir, "config")

	// Create SSH config with multiple hosts
	sshConfig := `Host prod-web
    HostName old-web.example.com
    User oldweb

Host prod-db
    HostName old-db.example.com
    User olddb

Host myserver
    HostName example.com
    User admin
`
	err := os.WriteFile(sshConfigPath, []byte(sshConfig), 0600)
	require.NoError(t, err)

	// Create 1Password servers with two conflicts
	onePasswordServers := []*domain.Server{
		{
			ID:          "srv-001",
			DisplayName: "prod-web",
			Host:        "new-web.example.com",
			User:        "newweb",
			Port:        22,
		},
		{
			ID:          "srv-002",
			DisplayName: "prod-db",
			Host:        "new-db.example.com",
			User:        "newdb",
			Port:        22,
		},
		{
			ID:          "srv-003",
			DisplayName: "staging-api",
			Host:        "staging.example.com",
			User:        "ubuntu",
			Port:        22,
		},
	}

	// Detect conflicts
	conflicts, err := DetectConflicts(onePasswordServers, sshConfigPath)
	require.NoError(t, err)

	// Verify two conflicts found
	require.Len(t, conflicts, 2, "Expected two conflicts")

	// Verify both have correct winner
	for _, conflict := range conflicts {
		assert.Equal(t, "onepassword", conflict.Winner)
		assert.NotNil(t, conflict.OnePassword)
		assert.NotNil(t, conflict.SSHConfig)
	}

	// Find specific conflicts
	var prodWebConflict, prodDbConflict *Conflict
	for i := range conflicts {
		switch conflicts[i].Alias {
		case "prod-web":
			prodWebConflict = &conflicts[i]
		case "prod-db":
			prodDbConflict = &conflicts[i]
		}
	}

	assert.NotNil(t, prodWebConflict, "Expected prod-web conflict")
	assert.NotNil(t, prodDbConflict, "Expected prod-db conflict")
}

func TestDetectConflicts_EmptySSHConfig(t *testing.T) {
	// Create temp directory for test
	tmpDir := t.TempDir()
	sshConfigPath := filepath.Join(tmpDir, "config")

	// Create empty SSH config
	err := os.WriteFile(sshConfigPath, []byte(""), 0600)
	require.NoError(t, err)

	// Create 1Password servers
	onePasswordServers := []*domain.Server{
		{
			ID:          "srv-001",
			DisplayName: "prod-web",
			Host:        "prod.example.com",
			User:        "deploy",
			Port:        22,
		},
	}

	// Detect conflicts
	conflicts, err := DetectConflicts(onePasswordServers, sshConfigPath)
	require.NoError(t, err)

	// Verify no conflicts
	assert.Len(t, conflicts, 0, "Expected no conflicts with empty SSH config")
}

func TestDetectConflicts_WithPortAndIdentityFile(t *testing.T) {
	tmpDir := t.TempDir()
	sshConfigPath := filepath.Join(tmpDir, "config")

	// Create SSH config with port and identity file
	sshConfig := `Host prod-web
    HostName old.example.com
    User olduser
    Port 2222
    IdentityFile ~/.ssh/id_rsa
    ProxyJump bastion.example.com
`
	err := os.WriteFile(sshConfigPath, []byte(sshConfig), 0600)
	require.NoError(t, err)

	onePasswordServers := []*domain.Server{
		{
			ID:          "srv-001",
			DisplayName: "prod-web",
			Host:        "new.example.com",
			User:        "deploy",
			Port:        22,
		},
	}

	conflicts, err := DetectConflicts(onePasswordServers, sshConfigPath)
	require.NoError(t, err)
	require.Len(t, conflicts, 1)

	// Verify the SSH config server was properly converted
	sshSrv := conflicts[0].SSHConfig
	assert.Equal(t, "old.example.com", sshSrv.Host)
	assert.Equal(t, "olduser", sshSrv.User)
	assert.Equal(t, 2222, sshSrv.Port)
	assert.Equal(t, "~/.ssh/id_rsa", sshSrv.IdentityFile)
	assert.Equal(t, "bastion.example.com", sshSrv.Proxy)
}

func TestDetectConflicts_NonExistentSSHConfig(t *testing.T) {
	// Create temp directory for test
	tmpDir := t.TempDir()
	sshConfigPath := filepath.Join(tmpDir, "nonexistent_config")

	// Create 1Password servers
	onePasswordServers := []*domain.Server{
		{
			ID:          "srv-001",
			DisplayName: "prod-web",
			Host:        "prod.example.com",
			User:        "deploy",
			Port:        22,
		},
	}

	// Detect conflicts (should handle non-existent file gracefully)
	conflicts, err := DetectConflicts(onePasswordServers, sshConfigPath)

	// Could either return error or empty list - both are acceptable
	// If it returns an error, verify it's about file not existing
	if err != nil {
		assert.Contains(t, err.Error(), "open SSH config")
	} else {
		// If no error, should return empty conflicts
		assert.Len(t, conflicts, 0)
	}
}
